---
created: 2025-11-29
updated: 2025-11-30
version: 0.2.0
status: ready
parent: '[[v0.2-spec]]'
---

# Rackarr v0.2 — Implementation Prompt Plan (Revised)

**Spec:** [[v0.2-spec|v0.2 Multi-View & Polish Specification]]

This document provides sequenced implementation prompts for v0.2 features.

---

## Overview

### Version Goal

Add rear rack view capability, improve canvas usability with fit-all zoom, enable rack duplication, enhance device library management, and apply UI polish.

### Approach

1. **Phase 1: Technical Foundation** — Complete coordinate migration, panzoom integration, fit-all zoom
2. **Phase 2: Core Features** — Rear view data model + UI, rack duplication
3. **Phase 3: UI Polish** — Toolbar, drawer, and rendering fixes
4. **Phase 4: Data & Migration** — Device library import, version handling

### Dependency Graph

```
Phase 1 (Foundation)
├── 1.1: Migrate to screenToSVG (P01 complete prerequisite)
│   └── 1.2: Install panzoom wrapper
│       └── 1.3: Canvas panzoom integration
│           └── 1.4: Verify drag-drop ← CRITICAL GATE
│               └── 1.5: Fit All calculations
│                   └── 1.6: Fit All button

Phase 2 (Core Features)
├── 2.1: Rear view types (independent, can start early)
│   ├── 2.2: Rack creation update
│   │   └── 2.4: Toggle component
│   │       └── 2.5: Rack integration
│   └── 2.3: Device placement update
│       └── 2.6: Edit panel face selector
└── 2.7: Duplication utilities (independent)
    └── 2.8: Duplication store/UI

Phase 3 (UI Polish)
├── 3.1: Library toggle
│   └── 3.2: Drawer changes
├── 3.3: Rack title (independent)
├── 3.4: Icon alignment (independent)
└── 3.5: Help panel (independent)

Phase 4 (Data)
├── 4.1: Import validation
│   └── 4.2: Import UI
└── 4.3: Migration logic (depends on 2.1)
    └── 4.4: Wire migration
```

### Pre-requisite Status

- **P01 (getScreenCTM coordinates):** ✅ Complete — `src/lib/utils/coordinates.ts` exists

---

## Phase 1: Technical Foundation

### Prompt 1.1 — Migrate Drag-Drop to Use New Coordinate Utilities

**Goal:** Complete the migration started in P01 by updating all drag-drop code to use screenToSVG.

**Context:**

- The file `src/lib/utils/coordinates.ts` contains `screenToSVG()` and `svgToScreen()` utilities
- These use getScreenCTM().inverse() to automatically handle all transforms
- Current drag-drop code likely uses getBoundingClientRect() + manual zoom division
- This migration is required before adding panzoom (which adds pan transforms)

**Files to examine:**

- `src/lib/utils/dragdrop.ts` — find calculateDropPosition(), getDropFeedback()
- `src/lib/components/Rack.svelte` — find drop handlers
- `src/lib/components/Canvas.svelte` — find any coordinate calculations
- Any file that passes `zoomScale` to coordinate functions

**TDD Steps:**

1. Write equivalence tests showing old and new calculations produce same results
2. Find all places using manual zoom compensation patterns:
   - `/ zoomScale` or `* zoomScale`
   - `getBoundingClientRect()` for drop calculations
   - `zoomScale` parameter in function signatures
3. Refactor each to use screenToSVG()
4. Run existing drag-drop tests to verify behavior preserved

**Tests first:**

```typescript
// src/lib/utils/coordinates.test.ts (additions)
describe('screenToSVG equivalence', () => {
	it('produces same result as manual zoom compensation', () => {
		// Compare old: (clientX - rect.left) / zoomScale
		// With new: screenToSVG(svg, clientX, clientY).x
	});
});
```

**Commit:** `refactor(dnd): migrate to screenToSVG coordinate utilities`

---

### Prompt 1.2 — Install and Configure panzoom Library

**Goal:** Add the panzoom dependency and create basic Svelte integration utilities.

**Context:**

- panzoom provides smooth zoom/pan for SVG elements
- We need to wrap the canvas content in a `<g>` element controlled by panzoom
- The library should integrate cleanly with Svelte 5's lifecycle

**Steps:**

1. Install panzoom: `npm install panzoom@^9.4.3`
2. Create `src/lib/utils/panzoom.ts` with TypeScript wrapper
3. Write tests for utility functions

**Tests first:**

```typescript
// src/lib/utils/panzoom.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { createPanzoomInstance, disposePanzoom, getTransform } from './panzoom';

describe('panzoom utilities', () => {
	let mockElement: SVGGElement;

	beforeEach(() => {
		mockElement = document.createElementNS('http://www.w3.org/2000/svg', 'g');
	});

	it('creates panzoom instance with correct options', () => {
		const instance = createPanzoomInstance(mockElement);
		expect(instance).toBeTruthy();
		expect(instance.getMinZoom()).toBe(0.25);
		expect(instance.getMaxZoom()).toBe(2);
		disposePanzoom(instance);
	});

	it('getTransform returns current state', () => {
		const instance = createPanzoomInstance(mockElement);
		const transform = getTransform(instance);
		expect(transform).toHaveProperty('x');
		expect(transform).toHaveProperty('y');
		expect(transform).toHaveProperty('scale');
		disposePanzoom(instance);
	});

	it('disposes without error', () => {
		const instance = createPanzoomInstance(mockElement);
		expect(() => disposePanzoom(instance)).not.toThrow();
	});
});
```

**Implementation:**

```typescript
// src/lib/utils/panzoom.ts
import panzoom from 'panzoom';
import type { PanZoom } from 'panzoom';

export type { PanZoom };

export interface PanzoomOptions {
	minZoom?: number;
	maxZoom?: number;
	bounds?: boolean;
}

const DEFAULT_OPTIONS: PanzoomOptions = {
	minZoom: 0.25,
	maxZoom: 2,
	bounds: true
};

export function createPanzoomInstance(element: SVGGElement, options: PanzoomOptions = {}): PanZoom {
	const mergedOptions = { ...DEFAULT_OPTIONS, ...options };

	return panzoom(element, {
		bounds: mergedOptions.bounds,
		maxZoom: mergedOptions.maxZoom,
		minZoom: mergedOptions.minZoom,
		smoothScroll: false,
		zoomDoubleClickSpeed: 1
	});
}

export function disposePanzoom(instance: PanZoom): void {
	instance.dispose();
}

export function getTransform(instance: PanZoom): { x: number; y: number; scale: number } {
	return instance.getTransform();
}
```

**Commit:** `feat(canvas): add panzoom utility wrapper`

---

### Prompt 1.3 — Integrate panzoom into Canvas Component

**Goal:** Update Canvas.svelte to use panzoom for zoom/pan control.

**Context:**

- Canvas currently uses CSS transform for zoom (scale only)
- panzoom needs to control a `<g>` wrapper element inside the SVG
- Existing zoom buttons should now control panzoom instance
- Coordinate utilities already use getScreenCTM() which works with panzoom transforms

**Structure change:**

```
Before: <svg> → <Rack /> ...
After:  <svg> → <g data-panzoom> → <Rack /> ...
```

**Tests first:**

```typescript
// src/lib/components/Canvas.test.ts (additions)
describe('Canvas panzoom integration', () => {
	it('renders panzoom container group', () => {
		const { container } = render(Canvas, { props: { racks: [] } });
		const panzoomGroup = container.querySelector('[data-panzoom]');
		expect(panzoomGroup).toBeTruthy();
	});

	it('zoom in increases scale', async () => {
		const { getByLabelText } = render(Canvas, { props: { racks: mockRacks } });
		// Get initial scale, click zoom in, verify increased
	});

	it('zoom out decreases scale', async () => {
		// Similar test
	});

	it('respects max zoom bound of 200%', async () => {
		// Click zoom in many times, verify doesn't exceed 2
	});

	it('respects min zoom bound of 25%', async () => {
		// Click zoom out many times, verify doesn't go below 0.25
	});

	it('disposes panzoom on unmount', async () => {
		const { unmount } = render(Canvas, { props: { racks: [] } });
		unmount();
		// Verify no errors, no memory leaks
	});
});
```

**Implementation notes:**

- Initialize panzoom on mount with onMount()
- Dispose on cleanup (return from onMount)
- Update zoom button handlers to use panzoomInstance.zoomAbs()
- Remove old CSS transform zoom code
- Store panzoom instance for external access (Fit All needs it)

**Commit:** `feat(canvas): integrate panzoom for zoom and pan`

---

### Prompt 1.4 — Verify Drag-Drop Works with panzoom

**Goal:** Critical verification that drag-drop still works correctly after panzoom integration.

**Context:**

- panzoom adds pan (translate) transforms in addition to zoom (scale)
- Our screenToSVG utility uses getScreenCTM() which should handle this
- If any drag-drop code was missed in 1.1, it will break now
- This is a verification/fix prompt, not new feature work

**Tests:**

```typescript
// src/lib/utils/dragdrop-panzoom.test.ts
describe('drag-drop with panzoom transforms', () => {
	it('calculates correct drop position at 50% zoom', async () => {
		// Setup canvas at 50% zoom
		// Simulate drag operation
		// Verify device placed at expected U
	});

	it('calculates correct drop position at 200% zoom', async () => {
		// Similar test at max zoom
	});

	it('calculates correct drop position after pan', async () => {
		// Setup canvas with pan offset
		// Simulate drag operation
		// Verify correct placement
	});

	it('handles combined zoom and pan', async () => {
		// Zoom to 150% + pan 100px right
		// Verify drag-drop still accurate
	});
});
```

**Steps:**

1. Run ALL existing drag-drop tests
2. Write new integration tests for zoom+pan scenarios
3. If any tests fail, fix coordinate calculations
4. Manual verification at various zoom/pan levels

**Commit:** `test(dnd): verify drag-drop works with panzoom transforms`

(If fixes needed: `fix(dnd): correct coordinate calculation with panzoom`)

---

### Prompt 1.5 — Fit All Calculation Utilities

**Goal:** Create pure functions for calculating fit-all zoom and pan values.

**Spec reference:** v0.2 Section 3.2

**Tests first:**

```typescript
// src/lib/utils/canvas.test.ts
import { describe, it, expect } from 'vitest';
import { calculateRacksBoundingBox, calculateFitAll } from './canvas';

describe('calculateRacksBoundingBox', () => {
	it('returns zero bounds for empty array', () => {
		const bounds = calculateRacksBoundingBox([]);
		expect(bounds).toEqual({ x: 0, y: 0, width: 0, height: 0 });
	});

	it('returns rack bounds for single rack', () => {
		const racks = [{ x: 100, y: 50, width: 200, height: 800 }];
		const bounds = calculateRacksBoundingBox(racks);
		expect(bounds).toEqual({ x: 100, y: 50, width: 200, height: 800 });
	});

	it('calculates encompassing bounds for multiple racks', () => {
		const racks = [
			{ x: 0, y: 0, width: 100, height: 100 },
			{ x: 200, y: 50, width: 100, height: 150 }
		];
		const bounds = calculateRacksBoundingBox(racks);
		expect(bounds).toEqual({ x: 0, y: 0, width: 300, height: 200 });
	});
});

describe('calculateFitAll', () => {
	it('returns default values for empty racks', () => {
		const result = calculateFitAll([], 800, 600);
		expect(result).toEqual({ zoom: 1, panX: 0, panY: 0 });
	});

	it('calculates zoom with 48px padding', () => {
		const racks = [{ x: 0, y: 0, width: 200, height: 400 }];
		const result = calculateFitAll(racks, 800, 600);
		expect(result.zoom).toBeGreaterThan(0);
		expect(result.zoom).toBeLessThanOrEqual(2);
	});

	it('caps zoom at 200%', () => {
		const racks = [{ x: 0, y: 0, width: 50, height: 50 }];
		const result = calculateFitAll(racks, 800, 600);
		expect(result.zoom).toBe(2);
	});

	it('centers content in viewport', () => {
		const racks = [{ x: 0, y: 0, width: 400, height: 300 }];
		const result = calculateFitAll(racks, 800, 600);
		expect(result.panX).toBeGreaterThan(0);
		expect(result.panY).toBeGreaterThan(0);
	});
});
```

**Implementation:**

```typescript
// src/lib/utils/canvas.ts
interface Bounds {
	x: number;
	y: number;
	width: number;
	height: number;
}

interface RackPosition {
	x: number;
	y: number;
	width: number;
	height: number;
}

export function calculateRacksBoundingBox(racks: RackPosition[]): Bounds {
	if (racks.length === 0) {
		return { x: 0, y: 0, width: 0, height: 0 };
	}

	let minX = Infinity,
		minY = Infinity;
	let maxX = -Infinity,
		maxY = -Infinity;

	for (const rack of racks) {
		minX = Math.min(minX, rack.x);
		minY = Math.min(minY, rack.y);
		maxX = Math.max(maxX, rack.x + rack.width);
		maxY = Math.max(maxY, rack.y + rack.height);
	}

	return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
}

export function calculateFitAll(
	racks: RackPosition[],
	viewportWidth: number,
	viewportHeight: number
): { zoom: number; panX: number; panY: number } {
	if (racks.length === 0) {
		return { zoom: 1, panX: 0, panY: 0 };
	}

	const bounds = calculateRacksBoundingBox(racks);
	const padding = 48;
	const contentWidth = bounds.width + padding * 2;
	const contentHeight = bounds.height + padding * 2;

	const zoomX = viewportWidth / contentWidth;
	const zoomY = viewportHeight / contentHeight;
	const zoom = Math.min(zoomX, zoomY, 2);

	const panX = (viewportWidth - bounds.width * zoom) / 2 - bounds.x * zoom;
	const panY = (viewportHeight - bounds.height * zoom) / 2 - bounds.y * zoom;

	return { zoom, panX, panY };
}
```

**Commit:** `feat(canvas): add fit-all calculation utilities`

---

### Prompt 1.6 — Fit All Button and Integration

**Goal:** Add Fit All button to toolbar and wire it to panzoom with animation.

**Spec reference:** v0.2 Section 3.2

**Tests first:**

```typescript
// Toolbar.test.ts additions
describe('Fit All button', () => {
	it('renders fit all button', () => {
		const { getByLabelText } = render(Toolbar);
		expect(getByLabelText(/fit all/i)).toBeTruthy();
	});

	it('calls fitAll on click', async () => {
		const mockFitAll = vi.fn();
		const { getByLabelText } = render(Toolbar, { props: { onfitall: mockFitAll } });
		await fireEvent.click(getByLabelText(/fit all/i));
		expect(mockFitAll).toHaveBeenCalled();
	});
});

// keyboard.test.ts additions
describe('Fit All shortcut', () => {
	it('F key triggers fit all', async () => {
		// Test F key calls fitAll
	});
});
```

**Implementation:**

1. Create IconFitAll.svelte (four arrows pointing outward)
2. Add button to Toolbar after zoom controls
3. Implement fitAll() function using calculateFitAll + panzoom
4. Add keyboard shortcut 'F'
5. Respect prefers-reduced-motion (instant vs 200ms animation)

**Commit:** `feat(canvas): add Fit All zoom button`

---

## Phase 2: Core Features

### Prompt 2.1 — Rear View Type Definitions

**Goal:** Extend type system to support front/rear views.

**Spec reference:** v0.2 Section 3.1.1

**Tests first:**

```typescript
// src/lib/types/types.test.ts
import { describe, it, expect } from 'vitest';
import type { Rack, PlacedDevice, RackView, DeviceFace } from './index';
import { DEFAULT_RACK_VIEW, DEFAULT_DEVICE_FACE } from './constants';

describe('RackView type', () => {
	it('accepts front view', () => {
		const view: RackView = 'front';
		expect(view).toBe('front');
	});

	it('accepts rear view', () => {
		const view: RackView = 'rear';
		expect(view).toBe('rear');
	});
});

describe('DeviceFace type', () => {
	it('accepts front, rear, and both', () => {
		const faces: DeviceFace[] = ['front', 'rear', 'both'];
		expect(faces).toHaveLength(3);
	});
});

describe('Default values', () => {
	it('DEFAULT_RACK_VIEW is front', () => {
		expect(DEFAULT_RACK_VIEW).toBe('front');
	});

	it('DEFAULT_DEVICE_FACE is front', () => {
		expect(DEFAULT_DEVICE_FACE).toBe('front');
	});
});
```

**Implementation:**

```typescript
// src/lib/types/index.ts additions
export type RackView = 'front' | 'rear';
export type DeviceFace = 'front' | 'rear' | 'both';

// Update Rack interface
export interface Rack {
	// ... existing properties
	view: RackView;
}

// Update PlacedDevice interface
export interface PlacedDevice {
	// ... existing properties
	face: DeviceFace;
}

// src/lib/types/constants.ts additions
export const DEFAULT_RACK_VIEW: RackView = 'front';
export const DEFAULT_DEVICE_FACE: DeviceFace = 'front';
```

**Commit:** `feat(types): add rear view type definitions`

---

### Prompt 2.2 — Update Rack Creation with View Property

**Goal:** Update rack utilities and store to include view property.

**Tests:**

```typescript
// Update existing createRack tests
it('creates rack with default front view', () => {
	const rack = createRack({ name: 'Test', height: 42 });
	expect(rack.view).toBe('front');
});

it('creates rack with specified rear view', () => {
	const rack = createRack({ name: 'Test', height: 42, view: 'rear' });
	expect(rack.view).toBe('rear');
});
```

**Steps:**

1. Update createRack() to accept optional view parameter
2. Default to DEFAULT_RACK_VIEW
3. Update layout store's addRack action
4. Fix any failing tests

**Commit:** `feat(rack): add view property to rack creation`

---

### Prompt 2.3 — Update Device Placement with Face Property

**Goal:** Update device placement utilities to include face property.

**Tests:**

```typescript
it('places device with default front face', () => {
	const placed = placeDevice({ libraryId: 'dev-1', position: 1 });
	expect(placed.face).toBe('front');
});

it('places device with specified face', () => {
	const placed = placeDevice({ libraryId: 'dev-1', position: 1, face: 'rear' });
	expect(placed.face).toBe('rear');
});
```

**Steps:**

1. Find all places that create PlacedDevice objects
2. Update each to include face property with default
3. Update drag-drop handlers if they create placements

**Commit:** `feat(device): add face property to device placement`

---

### Prompt 2.4 — Rack View Toggle Component

**Goal:** Create reusable RackViewToggle component.

**Spec reference:** v0.2 Section 3.1.2

**Tests first:**

```typescript
// src/lib/components/RackViewToggle.test.ts
import { describe, it, expect, vi } from 'vitest';
import { render, fireEvent } from '@testing-library/svelte';
import RackViewToggle from './RackViewToggle.svelte';

describe('RackViewToggle', () => {
	it('renders front and rear buttons', () => {
		const { getByRole } = render(RackViewToggle, {
			props: { view: 'front', onchange: vi.fn() }
		});
		expect(getByRole('button', { name: 'Front' })).toBeTruthy();
		expect(getByRole('button', { name: 'Rear' })).toBeTruthy();
	});

	it('marks current view as pressed', () => {
		const { getByRole } = render(RackViewToggle, {
			props: { view: 'front', onchange: vi.fn() }
		});
		expect(getByRole('button', { name: 'Front' })).toHaveAttribute('aria-pressed', 'true');
	});

	it('calls onchange when other view clicked', async () => {
		const onchange = vi.fn();
		const { getByRole } = render(RackViewToggle, {
			props: { view: 'front', onchange }
		});
		await fireEvent.click(getByRole('button', { name: 'Rear' }));
		expect(onchange).toHaveBeenCalledWith('rear');
	});
});
```

**Implementation:** Create segmented control with Front/Rear buttons, proper ARIA attributes, and styling per spec.

**Commit:** `feat(ui): add RackViewToggle component`

---

### Prompt 2.5 — Integrate View Toggle into Rack Component

**Goal:** Add RackViewToggle to Rack.svelte and filter devices by view.

**Tests:**

```typescript
// Rack.test.ts additions
describe('Rack view toggle', () => {
	it('renders view toggle', () => {
		const { getByRole } = render(Rack, { props: { rack: mockRack } });
		expect(getByRole('group', { name: 'Rack view' })).toBeTruthy();
	});

	it('shows front-face devices in front view', () => {
		const rack = {
			...mockRack,
			view: 'front',
			devices: [
				{ libraryId: 'd1', position: 1, face: 'front' },
				{ libraryId: 'd2', position: 5, face: 'rear' }
			]
		};
		const { container } = render(Rack, { props: { rack, deviceLibrary } });
		// Only front device visible
		expect(container.querySelectorAll('[data-device]')).toHaveLength(1);
	});

	it('shows both-face devices in either view', () => {
		const rack = {
			...mockRack,
			view: 'rear',
			devices: [{ libraryId: 'd1', position: 1, face: 'both' }]
		};
		const { container } = render(Rack, { props: { rack, deviceLibrary } });
		expect(container.querySelectorAll('[data-device]')).toHaveLength(1);
	});
});
```

**Implementation:**

- Add RackViewToggle above rack title
- Create $derived for visibleDevices filtering by face
- Add updateRackView action to layout store

**Commit:** `feat(rack): integrate view toggle and device filtering`

---

### Prompt 2.6 — Device Face Assignment in Edit Panel

**Goal:** Add face assignment radio buttons to EditPanel.

**Spec reference:** v0.2 Section 3.1.3

**Tests:**

```typescript
// EditPanel.test.ts additions
describe('Device face assignment', () => {
	it('shows face selector when device selected', () => {
		const { getByRole } = render(EditPanel, {
			props: { selectedDevice: mockPlacedDevice }
		});
		expect(getByRole('group', { name: /mounted face/i })).toBeTruthy();
	});

	it('has three radio options', () => {
		const { getByLabelText } = render(EditPanel, {
			props: { selectedDevice: mockPlacedDevice }
		});
		expect(getByLabelText('Front')).toBeTruthy();
		expect(getByLabelText('Rear')).toBeTruthy();
		expect(getByLabelText('Both (full-depth)')).toBeTruthy();
	});

	it('does not show face selector for rack selection', () => {
		const { queryByRole } = render(EditPanel, {
			props: { selectedRack: mockRack }
		});
		expect(queryByRole('group', { name: /mounted face/i })).toBeNull();
	});
});
```

**Implementation:** Add fieldset with radio buttons, wire to updateDeviceFace store action.

**Commit:** `feat(edit): add device face assignment`

---

### Prompt 2.7 — Rack Duplication Utilities

**Goal:** Create pure function for deep-copying a rack with new UUIDs.

**Spec reference:** v0.2 Section 3.3

**Tests first:**

```typescript
// src/lib/utils/rack.test.ts additions
describe('duplicateRack', () => {
	it('creates new rack with different ID', () => {
		const original = createMockRack({ id: 'rack-1' });
		const copy = duplicateRack(original);
		expect(copy.id).not.toBe(original.id);
	});

	it('appends (Copy) to name', () => {
		const original = createMockRack({ name: 'Main Rack' });
		const copy = duplicateRack(original);
		expect(copy.name).toBe('Main Rack (Copy)');
	});

	it('preserves rack properties including view', () => {
		const original = createMockRack({ height: 42, view: 'rear' });
		const copy = duplicateRack(original);
		expect(copy.height).toBe(42);
		expect(copy.view).toBe('rear');
	});

	it('copies all devices preserving positions and faces', () => {
		const original = createMockRack({
			devices: [
				{ libraryId: 'lib-1', position: 1, face: 'front' },
				{ libraryId: 'lib-2', position: 10, face: 'both' }
			]
		});
		const copy = duplicateRack(original);
		expect(copy.devices).toHaveLength(2);
		expect(copy.devices[0].position).toBe(1);
		expect(copy.devices[1].face).toBe('both');
	});

	it('positions copy after original', () => {
		const original = createMockRack({ position: 2 });
		const copy = duplicateRack(original);
		expect(copy.position).toBe(3);
	});
});
```

**Commit:** `feat(rack): add rack duplication utility`

---

### Prompt 2.8 — Rack Duplication Store Action and UI

**Goal:** Wire rack duplication to store and add UI triggers.

**Tests:**

```typescript
// layout store tests
describe('duplicateRack action', () => {
	it('duplicates rack and adds to layout', () => {
		layoutStore.duplicateRack('rack-1');
		expect(layoutStore.racks).toHaveLength(2);
	});

	it('returns error when 6 racks exist', () => {
		// Setup 6 racks
		const result = layoutStore.duplicateRack('rack-1');
		expect(result.error).toBe('Maximum of 6 racks allowed');
	});
});

// keyboard tests
describe('Rack duplication shortcut', () => {
	it('Ctrl+D duplicates selected rack', async () => {
		// Select rack, press Ctrl+D, verify duplicated
	});
});
```

**Implementation:**

- Add duplicateRack action to layout store
- Add to context menu (right-click rack)
- Add Ctrl/Cmd+D keyboard shortcut
- Show error toast at 6 rack limit

**Commit:** `feat(rack): add rack duplication action and shortcuts`

---

## Phase 3: UI Polish

### Prompt 3.1 — Device Library Toggle Button

**Goal:** Replace toolbar branding with functional Device Library toggle button.

**Spec reference:** v0.2 Section 2.2

**Tests:**

```typescript
describe('Device Library toggle', () => {
	it('renders icon and "Device Library" text', () => {
		const { getByRole } = render(Toolbar);
		expect(getByRole('button', { name: /device library/i })).toBeTruthy();
	});

	it('has aria-expanded reflecting drawer state', () => {
		const { getByRole } = render(Toolbar, { props: { drawerOpen: false } });
		expect(getByRole('button', { name: /device library/i })).toHaveAttribute(
			'aria-expanded',
			'false'
		);
	});

	it('has aria-controls pointing to drawer', () => {
		const { getByRole } = render(Toolbar);
		expect(getByRole('button', { name: /device library/i })).toHaveAttribute(
			'aria-controls',
			'device-library-drawer'
		);
	});

	it('shows active state when drawer open', () => {
		const { getByRole } = render(Toolbar, { props: { drawerOpen: true } });
		const toggle = getByRole('button', { name: /device library/i });
		expect(toggle.classList.contains('active')).toBe(true);
	});
});
```

**Implementation:** Create styled button with Rackarr icon + "Device Library" text, proper ARIA attributes, hover/active/focus states per spec CSS.

**Commit:** `feat(toolbar): add Device Library toggle button`

---

### Prompt 3.2 — Device Library Drawer Changes

**Goal:** Remove X close button from drawer, add proper id for aria-controls.

**Spec reference:** v0.2 Section 2.3

**Tests:**

```typescript
describe('Device Library drawer', () => {
	it('does not render X close button', () => {
		const { queryByLabelText } = render(DeviceLibraryDrawer, {
			props: { open: true }
		});
		expect(queryByLabelText(/close/i)).toBeNull();
	});

	it('has id for aria-controls', () => {
		const { container } = render(DeviceLibraryDrawer, { props: { open: true } });
		expect(container.querySelector('#device-library-drawer')).toBeTruthy();
	});

	it('closes on Escape key', async () => {
		const onClose = vi.fn();
		render(DeviceLibraryDrawer, { props: { open: true, onclose: onClose } });
		await fireEvent.keyDown(document, { key: 'Escape' });
		expect(onClose).toHaveBeenCalled();
	});

	it('closes on D key', async () => {
		const onClose = vi.fn();
		render(DeviceLibraryDrawer, { props: { open: true, onclose: onClose } });
		await fireEvent.keyDown(document, { key: 'd' });
		expect(onClose).toHaveBeenCalled();
	});
});
```

**Commit:** `refactor(drawer): remove X close button, add device-library-drawer id`

---

### Prompt 3.3 — Rack Title Position Above Rack

**Goal:** Move rack title from below to above the rack.

**Spec reference:** v0.2 Section 2.5

**Tests:**

```typescript
describe('Rack title positioning', () => {
	it('positions title above rack body', () => {
		const { container } = render(Rack, { props: { rack: mockRack } });
		const title = container.querySelector('.rack-title');
		const rackBody = container.querySelector('.rack-body');
		const titleY = parseFloat(title?.getAttribute('y') ?? '0');
		const bodyY = parseFloat(rackBody?.getAttribute('y') ?? '0');
		expect(titleY).toBeLessThan(bodyY);
	});

	it('centers title horizontally', () => {
		const { container } = render(Rack, { props: { rack: mockRack } });
		const title = container.querySelector('.rack-title');
		expect(title?.getAttribute('text-anchor')).toBe('middle');
	});
});
```

**Implementation:** Change title `<text>` y attribute to negative offset (-8), update export rendering.

**Commit:** `fix(ui): position rack title above rack`

---

### Prompt 3.4 — Device Icon Vertical Alignment

**Goal:** Vertically center category icons within device rectangles.

**Spec reference:** v0.2 Section 2.6

**Tests:**

```typescript
describe('Device icon alignment', () => {
	it('centers icon vertically via CSS', () => {
		const { container } = render(RackDevice, { props: { device: mockDevice } });
		const content = container.querySelector('.device-content');
		const styles = getComputedStyle(content!);
		expect(styles.alignItems).toBe('center');
	});
});
```

**Implementation:**

- CSS: `display: flex; align-items: center; height: 100%`
- SVG export: `dominant-baseline="middle"` and center Y calculation

**Commit:** `fix(ui): vertically center device icons`

---

### Prompt 3.5 — Help Panel Update

**Goal:** Remove Forgejo link, keep GitHub as primary.

**Spec reference:** v0.2 Section 2.4

**Tests:**

```typescript
describe('Help panel links', () => {
	it('shows GitHub repository link', () => {
		const { getByRole } = render(HelpPanel);
		expect(getByRole('link', { name: /github/i })).toBeTruthy();
	});

	it('does not show Forgejo link', () => {
		const { queryByText } = render(HelpPanel);
		expect(queryByText(/forgejo/i)).toBeNull();
	});
});
```

**Commit:** `docs(help): remove internal Forgejo link`

---

## Phase 4: Data & Migration

### Prompt 4.1 — Device Library Import Validation

**Goal:** Create validation utilities for device library import.

**Spec reference:** v0.2 Section 3.4

**Tests first:**

```typescript
// src/lib/utils/import.test.ts
describe('validateImportDevice', () => {
	it('accepts valid device', () => {
		const device = { name: 'Server', height: 2, category: 'server' };
		expect(validateImportDevice(device)).toBe(true);
	});

	it('rejects missing name', () => {
		expect(validateImportDevice({ height: 2, category: 'server' })).toBe(false);
	});

	it('rejects height < 0.5', () => {
		expect(validateImportDevice({ name: 'X', height: 0.4, category: 'server' })).toBe(false);
	});

	it('rejects height > 100', () => {
		expect(validateImportDevice({ name: 'X', height: 101, category: 'server' })).toBe(false);
	});

	it('rejects invalid category', () => {
		expect(validateImportDevice({ name: 'X', height: 2, category: 'invalid' })).toBe(false);
	});
});

describe('parseDeviceLibraryImport', () => {
	it('parses valid JSON', () => {
		const json = JSON.stringify({
			name: 'My Library',
			devices: [{ name: 'Server', height: 2, category: 'server' }]
		});
		const result = parseDeviceLibraryImport(json);
		expect(result.devices).toHaveLength(1);
		expect(result.skipped).toBe(0);
	});

	it('skips invalid entries and reports count', () => {
		const json = JSON.stringify({
			devices: [
				{ name: 'Valid', height: 2, category: 'server' },
				{ name: 'Invalid', height: -1, category: 'server' }
			]
		});
		const result = parseDeviceLibraryImport(json);
		expect(result.devices).toHaveLength(1);
		expect(result.skipped).toBe(1);
	});

	it('renames duplicates with (imported) suffix', () => {
		const existingNames = ['Server'];
		const json = JSON.stringify({
			devices: [{ name: 'Server', height: 2, category: 'server' }]
		});
		const result = parseDeviceLibraryImport(json, existingNames);
		expect(result.devices[0].name).toBe('Server (imported)');
	});
});
```

**Commit:** `feat(import): add device library import validation`

---

### Prompt 4.2 — Device Library Import UI

**Goal:** Add import button and file handling to Device Library drawer.

**Tests:**

```typescript
describe('Device Library import', () => {
	it('renders import button', () => {
		const { getByRole } = render(DeviceLibrary);
		expect(getByRole('button', { name: /import/i })).toBeTruthy();
	});

	it('accepts JSON files', () => {
		const { container } = render(DeviceLibrary);
		const input = container.querySelector('input[type="file"]');
		expect(input?.getAttribute('accept')).toBe('.json,application/json');
	});
});
```

**Implementation:**

- Add Import button near Add Device
- Hidden file input for JSON
- Parse file, validate, merge into store
- Show toast: "Imported X devices (Y skipped)"

**Commit:** `feat(import): add device library import UI`

---

### Prompt 4.3 — v0.1 to v0.2 Layout Migration

**Goal:** Create migration logic to load v0.1 layouts with new field defaults.

**Spec reference:** v0.2 Section 6

**Tests first:**

```typescript
// src/lib/utils/layout.test.ts
describe('migrateLayout', () => {
	it('adds view: front to v0.1 racks', () => {
		const v01Layout = {
			version: '0.1.0',
			racks: [{ id: '1', name: 'Test', height: 42, devices: [] }]
		};
		const result = migrateLayout(v01Layout);
		expect(result.racks[0].view).toBe('front');
	});

	it('adds face: front to v0.1 placed devices', () => {
		const v01Layout = {
			version: '0.1.0',
			racks: [
				{
					id: '1',
					devices: [{ libraryId: 'd1', position: 1 }]
				}
			]
		};
		const result = migrateLayout(v01Layout);
		expect(result.racks[0].devices[0].face).toBe('front');
	});

	it('preserves existing v0.2 values', () => {
		const v02Layout = {
			version: '0.2.0',
			racks: [
				{
					id: '1',
					view: 'rear',
					devices: [{ libraryId: 'd1', position: 1, face: 'both' }]
				}
			]
		};
		const result = migrateLayout(v02Layout);
		expect(result.racks[0].view).toBe('rear');
		expect(result.racks[0].devices[0].face).toBe('both');
	});

	it('updates version to 0.2.0', () => {
		const v01Layout = { version: '0.1.0', racks: [] };
		const result = migrateLayout(v01Layout);
		expect(result.version).toBe('0.2.0');
	});
});
```

**Commit:** `feat(migration): add v0.1 to v0.2 layout migration`

---

### Prompt 4.4 — Wire Migration into Load Flow

**Goal:** Call migrateLayout when loading layout files or session data.

**Tests:**

```typescript
describe('Layout loading with migration', () => {
	it('migrates v0.1 file on load', async () => {
		// Load v0.1 layout file
		// Verify racks have view property
	});

	it('migrates session data on restore', () => {
		// Store v0.1 layout in session
		// Call restoreFromSession
		// Verify migration applied
	});
});
```

**Implementation:**

- Update loadLayout in store to call migrateLayout
- Update session restore to call migrateLayout

**Commit:** `feat(migration): integrate migration into load flows`

---

## Success Criteria Checklist

After completing all prompts, verify:

### Core Features

- [ ] User can toggle between front/rear rack view
- [ ] Devices can be assigned to front, rear, or both faces
- [ ] "Fit All" zooms canvas to show all racks
- [ ] Racks can be duplicated with all devices
- [ ] Device library can be imported from JSON

### UI Polish

- [ ] Device Library button (with Rackarr icon) toggles drawer
- [ ] Device Library drawer has no X close button
- [ ] Rack titles appear above racks (canvas and export)
- [ ] Device icons are vertically centred
- [ ] Help panel shows only GitHub link (no Forgejo)

### Technical Foundation

- [ ] panzoom library integrated for canvas zoom/pan
- [ ] Coordinate handling uses getScreenCTM() for transform-aware positioning
- [ ] Drag-and-drop works correctly at all zoom levels and pan positions

### Compatibility

- [ ] All existing v0.1 functionality preserved
- [ ] v0.1 layouts load correctly with appropriate defaults

---

## Related Documents

- [[v0.2-spec|v0.2 Specification]]
- [[spec|Base Specification (v0.1)]]
- [[prompt_plan|v0.1 Prompt Plan]]
- [[v0.2-todo|v0.2 Progress Checklist]]

---

_Execute prompts in order. Each prompt includes tests-first approach per TDD protocol._
