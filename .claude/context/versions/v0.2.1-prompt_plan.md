---
created: 2025-11-30
updated: 2025-11-30
status: ready
version: 0.2.1
---

# Rackarr — Prompt Plan (v0.2.1)

**Generated:** 2025-11-30
**Spec Version:** 0.2.1 (Design Polish)
**Methodology:** Harper Reed LLM Codegen (TDD)
**Framework:** Svelte 5 with Runes
**Builds On:** v0.2.0 (Multi-View & Polish)
**Reference:** design-review-spec.md, design-methodology.md

---

## Overview

This plan breaks down the Rackarr v0.2.1 Design Polish release into **18 incremental, test-driven prompts** organised into **7 phases**. Each prompt builds on the previous with explicit dependencies — no orphaned code.

**Key Principles:**

- Svelte 5 runes (`$state`, `$derived`, `$effect`) throughout
- Tests written first with explicit test case names
- Progressive enhancement (visual improvements layer on existing functionality)
- No breaking changes to existing features
- WCAG AA accessibility compliance

**v0.2.1 Goals:**

- Visual drag affordance for device library items
- Drop zone highlighting during drag operations
- Complete interaction state coverage (hover, focus, active, disabled)
- Tooltip system for toolbar discoverability
- Animation system with motion preferences support
- Accessibility audit and fixes
- Design token consolidation

**Priority Levels:**

- **P0 (Critical):** Blocking usability issues
- **P1 (High):** Significant UX improvements
- **P2 (Medium):** Polish and refinement
- **P3 (Low):** Technical debt

---

## Phase 0: Design Token Foundation

### Prompt 0.1 — Design Token System

**Status:** ⬜ Pending
**Dependencies:** None (builds on v0.2 codebase)
**Priority:** P3 (Foundation for all other work)

```text
Create a consolidated design token system to enable consistent styling across all components.

1. Create src/lib/styles/tokens.css with three-layer structure:

   LAYER 1: PRIMITIVES (raw values)
   - Spacing scale (4px base): --space-0 through --space-12
   - Color palette neutrals: --neutral-50 through --neutral-950
   - Color palette blue (primary): --blue-50 through --blue-900
   - Color palette red (error): --red-50, --red-500, --red-600, --red-700
   - Color palette green (success): --green-50, --green-500, --green-600
   - Color palette amber (warning): --amber-50, --amber-500, --amber-600
   - Typography scale: --font-size-xs (11px) through --font-size-xl (18px)
   - Font weights: --font-weight-normal (400) through --font-weight-bold (700)
   - Line heights: --line-height-tight (1.25), --line-height-normal (1.5), --line-height-relaxed (1.75)
   - Border radius: --radius-sm (4px) through --radius-full (9999px)
   - Shadows: --shadow-sm through --shadow-xl
   - Timing: --duration-instant (0ms), --duration-fast (100ms), --duration-normal (200ms), --duration-slow (300ms)
   - Easing: --ease-linear, --ease-in, --ease-out, --ease-in-out, --ease-spring

   LAYER 2: SEMANTIC TOKENS (Dark Theme)
   - Backgrounds: --colour-bg, --colour-surface, --colour-surface-raised, --colour-surface-hover, --colour-surface-active
   - Text: --colour-text, --colour-text-muted, --colour-text-disabled
   - Borders: --colour-border, --colour-border-hover, --colour-border-focus
   - Interactive: --colour-selection, --colour-selection-hover, --colour-focus-ring
   - Semantic: --colour-success, --colour-warning, --colour-error
   - Drag and Drop: --colour-dnd-valid, --colour-dnd-valid-bg, --colour-dnd-invalid, --colour-dnd-invalid-bg, --colour-dnd-dragging

   LAYER 3: COMPONENT TOKENS
   - Rack: --rack-u-height, --rack-width, --rack-rail-width, --rack-padding, --rack-bg, --rack-slot, --rack-slot-alt, --rack-grid
   - Toolbar: --toolbar-height, --toolbar-bg, --toolbar-border
   - Drawer: --drawer-width, --drawer-bg
   - Device: --device-font-size, --device-padding, --device-radius, --device-ghost-opacity
   - Toast: --toast-bg, --toast-border, --toast-radius

2. Add light theme overrides in [data-theme='light'] selector:
   - Override all semantic tokens for light mode
   - Adjust shadows for lighter appearance

3. Update src/app.css to import tokens:
   @import './lib/styles/tokens.css';

4. Create migration checklist:
   - List all hardcoded color values in existing components
   - Document which token each should use

5. Write tests in src/tests/tokens.test.ts:
   - Test: "CSS custom properties are defined for all primitives"
   - Test: "Semantic tokens reference primitive values"
   - Test: "Light theme overrides semantic tokens"
   - Test: "Component tokens use semantic values"

Commit: "feat(tokens): add consolidated design token system"
```

---

### Prompt 0.2 — Token Migration

**Status:** ⬜ Pending
**Dependencies:** 0.1
**Priority:** P3

```text
Migrate existing components to use the new design token system.

1. Update src/app.css:
   - Replace all hardcoded color values with token references
   - Replace all hardcoded spacing with --space-* tokens
   - Replace all hardcoded font sizes with --font-size-* tokens
   - Replace all hardcoded shadows with --shadow-* tokens
   - Replace all hardcoded transitions with --duration-* and --ease-* tokens

2. Update component styles (embedded <style> blocks):

   Files to update:
   - src/lib/components/Toolbar.svelte
   - src/lib/components/Rack.svelte
   - src/lib/components/RackDevice.svelte
   - src/lib/components/DevicePalette.svelte
   - src/lib/components/DevicePaletteItem.svelte
   - src/lib/components/EditPanel.svelte
   - src/lib/components/Drawer.svelte
   - src/lib/components/Dialog.svelte
   - src/lib/components/Toast.svelte

   For each file:
   - Replace inline colors with var(--colour-*)
   - Replace inline spacing with var(--space-*)
   - Replace inline font sizes with var(--font-size-*)
   - Ensure transitions use token durations

3. Verify no hardcoded values remain:
   - Search for hex color patterns: #[0-9a-fA-F]{3,6}
   - Search for rgb/rgba patterns
   - Search for px values that should be tokens

4. Test visual consistency:
   - Compare before/after screenshots
   - Verify dark theme still works
   - Verify light theme still works

5. Write tests in src/tests/tokenMigration.test.ts:
   - Test: "No hardcoded hex colors in app.css"
   - Test: "Components render correctly with tokens"
   - Test: "Theme switching still works"

Commit: "refactor(styles): migrate all components to design tokens"
```

---

## Phase 1: Drag Affordance System

### Prompt 1.1 — Grip Icon Component

**Status:** ⬜ Pending
**Dependencies:** 0.2
**Priority:** P0

```text
Create the grip icon component for drag affordance.

1. Create src/lib/components/icons/IconGrip.svelte:

   Props:
   - size: number (default: 16)

   SVG content:
   - 6-dot grip pattern (2 columns × 3 rows)
   - Each dot: circle with r="1.5"
   - Positions: cx=5/11, cy=3/8/13
   - fill="currentColor" for theme compatibility
   - aria-hidden="true"

2. Export from src/lib/components/icons/index.ts:
   export { default as IconGrip } from './IconGrip.svelte';

3. Write tests in src/tests/IconGrip.test.ts:
   - Test: "IconGrip renders with default size 16"
   - Test: "IconGrip renders with custom size"
   - Test: "IconGrip has aria-hidden attribute"
   - Test: "IconGrip contains 6 circles"

Commit: "feat(icons): add grip icon for drag affordance"
```

---

### Prompt 1.2 — Device Palette Item Drag Affordance

**Status:** ⬜ Pending
**Dependencies:** 1.1
**Priority:** P0

```text
Add visual drag affordance to device library items.

1. Update src/lib/components/DevicePaletteItem.svelte:

   Import IconGrip component.

   Add state:
   - let isDragging = $state(false);

   Update template structure:
   <div
     class="device-palette-item"
     class:dragging={isDragging}
     draggable="true"
     role="option"
     tabindex="0"
     on:dragstart={handleDragStart}
     on:dragend={handleDragEnd}
   >
     <span class="drag-handle" aria-hidden="true">
       <IconGrip size={16} />
     </span>
     <span class="category-indicator" style="background-color: {device.colour}"></span>
     <span class="device-name">{device.name}</span>
     <span class="device-height">{device.height}U</span>
   </div>

   Add handlers:
   function handleDragStart(e: DragEvent) {
     isDragging = true;
     // existing drag logic
   }
   function handleDragEnd() {
     isDragging = false;
   }

2. Add CSS styles to component or app.css:

   .device-palette-item {
     display: flex;
     align-items: center;
     gap: var(--space-2);
     padding: var(--space-2) var(--space-3);
     border-radius: var(--radius-sm);
     cursor: grab;
     transition:
       transform var(--duration-fast) var(--ease-out),
       box-shadow var(--duration-fast) var(--ease-out),
       background-color var(--duration-fast) var(--ease-out);
   }

   .device-palette-item:hover {
     background-color: var(--colour-surface-hover);
     transform: translateY(-1px);
     box-shadow: var(--shadow-sm);
   }

   .device-palette-item:active,
   .device-palette-item.dragging {
     cursor: grabbing;
     transform: translateY(-2px) scale(1.02);
     box-shadow: var(--shadow-lg);
     z-index: 100;
   }

   .device-palette-item .drag-handle {
     color: var(--colour-text-muted);
     opacity: 0.5;
     transition: opacity var(--duration-fast) var(--ease-out);
   }

   .device-palette-item:hover .drag-handle {
     opacity: 1;
   }

   .device-palette-item .category-indicator {
     width: 4px;
     height: 100%;
     min-height: 24px;
     border-radius: 2px;
     flex-shrink: 0;
   }

   .device-palette-item .device-height {
     background-color: var(--colour-surface-raised);
     padding: 2px 8px;
     border-radius: var(--radius-full);
     font-size: var(--font-size-xs);
     font-weight: var(--font-weight-medium);
     margin-left: auto;
   }

3. Write tests in src/tests/DevicePaletteItem.test.ts:
   - Test: "Device item displays grip handle icon"
   - Test: "Cursor changes to grab on hover"
   - Test: "Item lifts with shadow on hover"
   - Test: "Item scales up when dragging"
   - Test: "Grip handle becomes visible on hover"
   - Test: "Category indicator shows device color"
   - Test: "Height badge shows U count"

Commit: "feat(dnd): add drag affordance to device palette items"
```

---

### Prompt 1.3 — Drop Zone Highlighting

**Status:** ⬜ Pending
**Dependencies:** 1.2
**Priority:** P0

```text
Add visual drop zone feedback during drag operations.

1. Update src/lib/components/Rack.svelte:

   Add drag state:
   let dragOverPosition: number | null = $state(null);
   let dragDeviceHeight: number = $state(1);
   let isDragValid: boolean = $state(true);

   Add handlers:
   function handleDragOver(event: DragEvent, uPosition: number) {
     event.preventDefault();
     const dragData = getDragData(event);
     if (dragData) {
       dragOverPosition = uPosition;
       dragDeviceHeight = dragData.deviceHeight;
       isDragValid = canPlaceAt(uPosition, dragDeviceHeight);
     }
   }

   function handleDragLeave() {
     dragOverPosition = null;
   }

   function handleDrop(event: DragEvent, uPosition: number) {
     // existing drop logic
     dragOverPosition = null;
   }

2. Update U slot rendering in Rack.svelte:

   {#each Array(rack.height) as _, i}
     {@const uPosition = rack.height - i}
     {@const isDropTarget = dragOverPosition !== null &&
       uPosition >= dragOverPosition &&
       uPosition < dragOverPosition + dragDeviceHeight}

     <rect
       class="u-slot"
       class:drop-target={isDropTarget}
       class:drop-valid={isDropTarget && isDragValid}
       class:drop-invalid={isDropTarget && !isDragValid}
       x={RAIL_WIDTH}
       y={i * uHeight}
       width={rackWidth - RAIL_WIDTH * 2}
       height={uHeight}
       on:dragover={(e) => handleDragOver(e, uPosition)}
       on:dragleave={handleDragLeave}
       on:drop={(e) => handleDrop(e, uPosition)}
     />
   {/each}

3. Add ghost preview rectangle:

   {#if dragOverPosition !== null && isDragValid}
     <rect
       class="drop-preview"
       x={RAIL_WIDTH + 2}
       y={(rack.height - dragOverPosition - dragDeviceHeight + 1) * uHeight}
       width={rackWidth - RAIL_WIDTH * 2 - 4}
       height={dragDeviceHeight * uHeight}
       rx="2"
     />
   {/if}

4. Add CSS for drop zones:

   .u-slot {
     fill: transparent;
     stroke: var(--colour-rack-grid, var(--rack-grid));
     stroke-width: 0.5;
     transition: fill var(--duration-fast) var(--ease-out);
   }

   .u-slot:hover:not(.occupied) {
     fill: rgba(255, 255, 255, 0.03);
   }

   .u-slot.drop-target.drop-valid {
     fill: var(--colour-dnd-valid-bg);
     stroke: var(--colour-dnd-valid);
     stroke-width: 2;
   }

   .u-slot.drop-target.drop-invalid {
     fill: var(--colour-dnd-invalid-bg);
     stroke: var(--colour-dnd-invalid);
     stroke-width: 2;
     cursor: no-drop;
   }

   .drop-preview {
     fill: none;
     stroke: var(--colour-dnd-valid);
     stroke-width: 2;
     stroke-dasharray: 4 2;
     pointer-events: none;
     opacity: 0.8;
   }

5. Write tests in src/tests/DropZone.test.ts:
   - Test: "U slots have subtle visual distinction"
   - Test: "Drag over highlights target slots in blue"
   - Test: "Multi-U device highlights all affected slots"
   - Test: "Invalid drop position shows red highlight"
   - Test: "Invalid drop position shows no-drop cursor"
   - Test: "Ghost preview shows landing position"
   - Test: "Drop zone clears on drag leave"

Commit: "feat(dnd): add drop zone visual feedback"
```

---

## Phase 2: Interaction States

### Prompt 2.1 — Toolbar Button States

**Status:** ⬜ Pending
**Dependencies:** 0.2
**Priority:** P1

```text
Implement complete interaction state coverage for toolbar buttons.

1. Update or create src/lib/components/ToolbarButton.svelte:

   Props:
   - icon: Component
   - label?: string
   - disabled?: boolean (default: false)
   - active?: boolean (default: false)
   - tooltip?: string

   Template:
   <button
     class="toolbar-button"
     class:active
     {disabled}
     aria-label={tooltip}
     title={tooltip}
     on:click
   >
     <svelte:component this={icon} size={20} />
     {#if label}
       <span class="label">{label}</span>
     {/if}
   </button>

2. Add comprehensive CSS states:

   .toolbar-button {
     display: inline-flex;
     align-items: center;
     gap: var(--space-2);
     padding: var(--space-2) var(--space-3);
     border: none;
     border-radius: var(--radius-md);
     background: transparent;
     color: var(--colour-text);
     cursor: pointer;
     transition:
       background-color var(--duration-fast) var(--ease-out),
       color var(--duration-fast) var(--ease-out),
       transform var(--duration-fast) var(--ease-out);
   }

   /* Hover state */
   .toolbar-button:hover:not(:disabled) {
     background-color: var(--colour-surface-hover);
   }

   /* Focus state - CRITICAL for accessibility */
   .toolbar-button:focus-visible {
     outline: none;
     box-shadow: 0 0 0 2px var(--colour-bg), 0 0 0 4px var(--colour-focus-ring);
   }

   /* Active/pressed state */
   .toolbar-button:active:not(:disabled) {
     transform: scale(0.97);
     background-color: var(--colour-surface-active);
   }

   /* Toggle active state */
   .toolbar-button.active {
     background-color: color-mix(in srgb, var(--colour-selection) 20%, transparent);
     color: var(--colour-selection);
   }

   /* Disabled state */
   .toolbar-button:disabled {
     opacity: 0.5;
     cursor: not-allowed;
   }

3. Update Toolbar.svelte to use ToolbarButton for all buttons.

4. Write tests in src/tests/ToolbarButton.test.ts:
   - Test: "Button renders in rest state"
   - Test: "Button shows hover state on mouse enter"
   - Test: "Button shows focus ring on keyboard focus"
   - Test: "Button scales down on active/pressed"
   - Test: "Button shows active toggle state when active=true"
   - Test: "Button appears disabled when disabled=true"
   - Test: "Disabled button is not clickable"
   - Test: "Button has aria-label when tooltip provided"

Commit: "feat(ui): add complete toolbar button interaction states"
```

---

### Prompt 2.2 — Form Input States

**Status:** ⬜ Pending
**Dependencies:** 2.1
**Priority:** P1

```text
Implement complete interaction state coverage for form inputs.

1. Add form input styles to src/app.css:

   .input-field {
     width: 100%;
     padding: var(--space-2) var(--space-3);
     border: 1px solid var(--colour-border);
     border-radius: var(--radius-md);
     background-color: var(--colour-surface);
     color: var(--colour-text);
     font-size: var(--font-size-base);
     transition:
       border-color var(--duration-fast) var(--ease-out),
       box-shadow var(--duration-fast) var(--ease-out);
   }

   /* Hover state */
   .input-field:hover:not(:disabled):not(:focus) {
     border-color: var(--colour-border-hover);
   }

   /* Focus state */
   .input-field:focus {
     outline: none;
     border-color: var(--colour-border-focus);
     box-shadow: 0 0 0 3px color-mix(in srgb, var(--colour-selection) 25%, transparent);
   }

   /* Invalid state */
   .input-field:invalid,
   .input-field.error {
     border-color: var(--colour-error);
   }

   .input-field:invalid:focus,
   .input-field.error:focus {
     box-shadow: 0 0 0 3px color-mix(in srgb, var(--colour-error) 25%, transparent);
   }

   /* Disabled state */
   .input-field:disabled {
     opacity: 0.5;
     cursor: not-allowed;
     background-color: var(--colour-surface-muted, rgba(255, 255, 255, 0.02));
   }

   /* Error message */
   .input-error {
     color: var(--colour-error);
     font-size: var(--font-size-xs);
     margin-top: var(--space-1);
   }

2. Update EditPanel.svelte inputs to use .input-field class.

3. Update NewRackForm.svelte inputs to use .input-field class.

4. Update AddDeviceForm.svelte inputs to use .input-field class.

5. Write tests in src/tests/FormInputs.test.ts:
   - Test: "Input renders in rest state"
   - Test: "Input shows hover state on mouse enter"
   - Test: "Input shows focus ring on focus"
   - Test: "Input shows error state when invalid"
   - Test: "Input appears disabled when disabled"
   - Test: "Error message displays below invalid input"

Commit: "feat(ui): add complete form input interaction states"
```

---

### Prompt 2.3 — Selection State Indicators

**Status:** ⬜ Pending
**Dependencies:** 2.2
**Priority:** P1

```text
Add clear visual indicators for selected items.

1. Update src/lib/components/Rack.svelte for rack selection:

   Add class binding:
   <g class="rack-container" class:selected={isSelected}>

   Add CSS:
   .rack-container.selected {
     outline: 2px solid var(--colour-selection);
     outline-offset: 4px;
   }

   .rack-container.selected .rack-header {
     background-color: color-mix(in srgb, var(--colour-selection) 10%, transparent);
   }

2. Update src/lib/components/RackDevice.svelte for device selection:

   Add class binding:
   <g class="rack-device" class:selected={isSelected}>

   Add CSS:
   .rack-device.selected {
     outline: 2px solid var(--colour-selection);
     outline-offset: 1px;
   }

   .rack-device.selected::after {
     content: '';
     position: absolute;
     inset: -4px;
     border: 2px solid var(--colour-selection);
     border-radius: var(--radius-sm);
     pointer-events: none;
     animation: selection-pulse 2s ease-in-out infinite;
   }

   @keyframes selection-pulse {
     0%, 100% { opacity: 0.5; }
     50% { opacity: 1; }
   }

3. Add selection state to device library for consistency:

   Update DevicePaletteItem.svelte when device is selected in library:
   .device-palette-item.library-selected {
     background-color: color-mix(in srgb, var(--colour-selection) 15%, transparent);
     border: 1px solid var(--colour-selection);
   }

4. Write tests in src/tests/SelectionStates.test.ts:
   - Test: "Selected rack shows blue outline"
   - Test: "Selected rack header has highlight"
   - Test: "Selected device shows prominent indicator"
   - Test: "Selection pulse animation runs"
   - Test: "Library device shows selection when active"

Commit: "feat(ui): add clear selection state indicators"
```

---

## Phase 3: Tooltip System

### Prompt 3.1 — Tooltip Component

**Status:** ⬜ Pending
**Dependencies:** 2.1
**Priority:** P1

```text
Create a reusable tooltip component for toolbar discoverability.

1. Create src/lib/components/Tooltip.svelte:

   Props:
   - text: string
   - shortcut?: string
   - position?: 'top' | 'bottom' | 'left' | 'right' (default: 'bottom')

   State:
   let visible = $state(false);
   let timeout: ReturnType<typeof setTimeout>;

   Functions:
   function show() {
     timeout = setTimeout(() => visible = true, 500);
   }
   function hide() {
     clearTimeout(timeout);
     visible = false;
   }

   Template:
   <div
     class="tooltip-wrapper"
     on:mouseenter={show}
     on:mouseleave={hide}
     on:focus={show}
     on:blur={hide}
   >
     <slot />

     {#if visible}
       <div class="tooltip tooltip-{position}" role="tooltip">
         <span class="tooltip-text">{text}</span>
         {#if shortcut}
           <kbd class="tooltip-shortcut">{shortcut}</kbd>
         {/if}
       </div>
     {/if}
   </div>

2. Add scoped styles:

   <style>
     .tooltip-wrapper {
       position: relative;
       display: inline-flex;
     }

     .tooltip {
       position: absolute;
       z-index: 1000;
       display: flex;
       align-items: center;
       gap: var(--space-2);
       padding: 6px 10px;
       background-color: var(--colour-surface-raised);
       border: 1px solid var(--colour-border);
       border-radius: var(--radius-md);
       box-shadow: var(--shadow-md);
       white-space: nowrap;
       pointer-events: none;
       animation: tooltip-fade-in 150ms var(--ease-out);
     }

     .tooltip-bottom {
       top: 100%;
       left: 50%;
       transform: translateX(-50%);
       margin-top: var(--space-2);
     }

     .tooltip-top {
       bottom: 100%;
       left: 50%;
       transform: translateX(-50%);
       margin-bottom: var(--space-2);
     }

     .tooltip-left {
       right: 100%;
       top: 50%;
       transform: translateY(-50%);
       margin-right: var(--space-2);
     }

     .tooltip-right {
       left: 100%;
       top: 50%;
       transform: translateY(-50%);
       margin-left: var(--space-2);
     }

     .tooltip-text {
       font-size: var(--font-size-sm);
       color: var(--colour-text);
     }

     .tooltip-shortcut {
       font-size: var(--font-size-xs);
       font-family: var(--font-mono, monospace);
       padding: 2px 6px;
       background-color: var(--colour-surface);
       border-radius: var(--radius-sm);
       color: var(--colour-text-muted);
     }

     @keyframes tooltip-fade-in {
       from { opacity: 0; transform: translateX(-50%) translateY(-4px); }
       to { opacity: 1; transform: translateX(-50%) translateY(0); }
     }
   </style>

3. Write tests in src/tests/Tooltip.test.ts:
   - Test: "Tooltip hidden by default"
   - Test: "Tooltip appears after 500ms hover"
   - Test: "Tooltip shows text content"
   - Test: "Tooltip shows keyboard shortcut when provided"
   - Test: "Tooltip hides on mouse leave"
   - Test: "Tooltip positions correctly for each position option"
   - Test: "Tooltip has correct ARIA role"

Commit: "feat(components): add Tooltip component"
```

---

### Prompt 3.2 — Toolbar Tooltips Integration

**Status:** ⬜ Pending
**Dependencies:** 3.1
**Priority:** P1

```text
Add tooltips to all toolbar buttons for discoverability.

1. Update src/lib/components/Toolbar.svelte:

   Import Tooltip component.

   Wrap each toolbar button with Tooltip:

   <!-- Device Library Toggle -->
   <Tooltip text="Device Library" shortcut="D">
     <ToolbarButton
       icon={IconPalette}
       active={$leftDrawerOpen}
       on:click={toggleLeftDrawer}
     />
   </Tooltip>

   <!-- File Operations -->
   <Tooltip text="New Rack" shortcut="N">
     <ToolbarButton icon={IconPlus} on:click={openNewRackForm} />
   </Tooltip>

   <Tooltip text="Save Layout" shortcut="Ctrl+S">
     <ToolbarButton icon={IconSave} on:click={saveLayout} />
   </Tooltip>

   <Tooltip text="Export Image" shortcut="Ctrl+E">
     <ToolbarButton icon={IconExport} on:click={openExportDialog} />
   </Tooltip>

   <Tooltip text="Load Layout" shortcut="Ctrl+O">
     <ToolbarButton icon={IconLoad} on:click={loadLayout} />
   </Tooltip>

   <Tooltip text="Delete Selected" shortcut="Del">
     <ToolbarButton
       icon={IconTrash}
       disabled={!$hasSelection}
       on:click={deleteSelected}
     />
   </Tooltip>

   <!-- Zoom Controls -->
   <Tooltip text="Zoom Out" shortcut="-">
     <ToolbarButton icon={IconZoomOut} disabled={!$canZoomOut} on:click={zoomOut} />
   </Tooltip>

   <Tooltip text="Zoom In" shortcut="+">
     <ToolbarButton icon={IconZoomIn} disabled={!$canZoomIn} on:click={zoomIn} />
   </Tooltip>

   <Tooltip text="Fit All Racks" shortcut="F">
     <ToolbarButton icon={IconFitAll} on:click={fitAll} />
   </Tooltip>

   <!-- Settings -->
   <Tooltip text="Toggle Theme">
     <ToolbarButton
       icon={$theme === 'dark' ? IconSun : IconMoon}
       on:click={toggleTheme}
     />
   </Tooltip>

   <Tooltip text="Help & Shortcuts" shortcut="?">
     <ToolbarButton icon={IconHelp} on:click={openHelp} />
   </Tooltip>

2. Add toolbar divider styling:

   .toolbar-divider {
     width: 1px;
     height: 24px;
     background-color: var(--colour-border);
     margin: 0 var(--space-2);
   }

3. Add zoom display styling:

   .zoom-display {
     min-width: 48px;
     text-align: center;
     font-size: var(--font-size-sm);
     font-variant-numeric: tabular-nums;
     color: var(--colour-text-muted);
   }

4. Write tests in src/tests/ToolbarTooltips.test.ts:
   - Test: "Every toolbar button has a tooltip"
   - Test: "Tooltips show correct text for each button"
   - Test: "Tooltips show keyboard shortcuts where applicable"
   - Test: "Tooltips have consistent styling"
   - Test: "Toolbar has visual dividers between groups"

Commit: "feat(toolbar): add tooltips to all toolbar buttons"
```

---

## Phase 4: Accessibility

### Prompt 4.1 — Focus Management Utilities

**Status:** ⬜ Pending
**Dependencies:** 2.1
**Priority:** P1

```text
Create focus management utilities for dialogs and modals.

1. Create src/lib/utils/focus.ts:

   /**
    * Svelte action to trap focus within an element.
    * Used for dialogs and modals to prevent focus escaping.
    */
   export function trapFocus(node: HTMLElement) {
     const focusableSelector =
       'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';

     function getFocusableElements() {
       return node.querySelectorAll<HTMLElement>(focusableSelector);
     }

     function handleKeyDown(event: KeyboardEvent) {
       if (event.key !== 'Tab') return;

       const focusableElements = getFocusableElements();
       const firstFocusable = focusableElements[0];
       const lastFocusable = focusableElements[focusableElements.length - 1];

       if (event.shiftKey) {
         if (document.activeElement === firstFocusable) {
           event.preventDefault();
           lastFocusable?.focus();
         }
       } else {
         if (document.activeElement === lastFocusable) {
           event.preventDefault();
           firstFocusable?.focus();
         }
       }
     }

     node.addEventListener('keydown', handleKeyDown);

     return {
       destroy() {
         node.removeEventListener('keydown', handleKeyDown);
       }
     };
   }

   /**
    * Focus the first focusable element within a container.
    */
   export function focusFirst(container: HTMLElement): void {
     const focusable = container.querySelector<HTMLElement>(
       'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
     );
     focusable?.focus();
   }

   /**
    * Store and restore focus for modal management.
    */
   export function createFocusManager() {
     let previousFocus: HTMLElement | null = null;

     return {
       save() {
         previousFocus = document.activeElement as HTMLElement;
       },
       restore() {
         previousFocus?.focus();
         previousFocus = null;
       }
     };
   }

2. Export from utils/index.ts:
   export * from './focus';

3. Write tests in src/tests/focus.test.ts:
   - Test: "trapFocus prevents focus from leaving container"
   - Test: "Tab wraps from last to first element"
   - Test: "Shift+Tab wraps from first to last element"
   - Test: "focusFirst focuses first focusable element"
   - Test: "Focus manager saves and restores focus"

Commit: "feat(a11y): add focus management utilities"
```

---

### Prompt 4.2 — Dialog Accessibility

**Status:** ⬜ Pending
**Dependencies:** 4.1
**Priority:** P1

```text
Update Dialog component with proper accessibility features.

1. Update src/lib/components/Dialog.svelte:

   Import focus utilities:
   import { trapFocus, focusFirst, createFocusManager } from '$lib/utils/focus';

   Add focus management:
   let dialogElement: HTMLDivElement;
   const focusManager = createFocusManager();

   $effect(() => {
     if (open) {
       focusManager.save();
       // Focus first element after mount
       setTimeout(() => focusFirst(dialogElement), 0);
     } else {
       focusManager.restore();
     }
   });

   Add escape key handling:
   function handleKeydown(event: KeyboardEvent) {
     if (event.key === 'Escape') {
       dispatch('close');
     }
   }

   Update template:
   {#if open}
     <div
       class="dialog-backdrop"
       on:click={() => dispatch('close')}
       on:keydown={handleKeydown}
     >
       <div
         bind:this={dialogElement}
         class="dialog"
         role="dialog"
         aria-modal="true"
         aria-labelledby="dialog-title"
         use:trapFocus
         on:click|stopPropagation
       >
         <h2 id="dialog-title" class="dialog-title">
           <slot name="title" />
         </h2>
         <div class="dialog-content">
           <slot />
         </div>
         <div class="dialog-actions">
           <slot name="actions" />
         </div>
       </div>
     </div>
   {/if}

2. Add ARIA live regions for dynamic content:

   If dialog shows status messages, add:
   <div role="status" aria-live="polite" class="sr-only">
     {statusMessage}
   </div>

3. Add screen reader only utility class:

   .sr-only {
     position: absolute;
     width: 1px;
     height: 1px;
     padding: 0;
     margin: -1px;
     overflow: hidden;
     clip: rect(0, 0, 0, 0);
     white-space: nowrap;
     border: 0;
   }

4. Write tests in src/tests/DialogA11y.test.ts:
   - Test: "Dialog has role='dialog'"
   - Test: "Dialog has aria-modal='true'"
   - Test: "Dialog has aria-labelledby pointing to title"
   - Test: "Focus moves to dialog on open"
   - Test: "Focus returns to trigger on close"
   - Test: "Focus is trapped within dialog"
   - Test: "Escape key closes dialog"
   - Test: "Click outside closes dialog"

Commit: "feat(a11y): update Dialog component with accessibility features"
```

---

### Prompt 4.3 — ARIA Labels Audit

**Status:** ⬜ Pending
**Dependencies:** 4.2
**Priority:** P1

```text
Audit and fix ARIA labels across all interactive elements.

1. Audit all icon-only buttons:

   Files to check:
   - src/lib/components/Toolbar.svelte
   - src/lib/components/EditPanel.svelte
   - src/lib/components/Dialog.svelte
   - src/lib/components/Drawer.svelte
   - src/lib/components/Canvas.svelte

   For each icon button, ensure:
   - aria-label describes the action
   - Or visible text label exists

2. Fix toolbar buttons (if not already done):

   <button aria-label="Add new rack">
     <IconPlus />
   </button>

3. Add labels to drawer controls:

   <button aria-label="Close device library" on:click={closeDrawer}>
     <IconClose />
   </button>

4. Add labels to form controls:

   Ensure every input has associated label:
   <label for="rack-name">Rack Name</label>
   <input id="rack-name" ... />

   Or use aria-label for inputs without visible labels:
   <input aria-label="Search devices" ... />

5. Add labels to canvas elements:

   For SVG interactive elements:
   <g role="button" aria-label="Rack: {rack.name}" tabindex="0">

   For devices:
   <g role="listitem" aria-label="{device.name} at U{position}">

6. Create ARIA audit checklist:

   Create docs/a11y-checklist.md:
   - [ ] All buttons have aria-label or visible text
   - [ ] All inputs have associated labels
   - [ ] All images have alt text
   - [ ] Focus order is logical
   - [ ] Focus indicators are visible
   - [ ] Color is not sole indicator
   - [ ] Error states announced to screen readers

7. Write tests in src/tests/AriaAudit.test.ts:
   - Test: "All toolbar buttons have aria-label"
   - Test: "All form inputs have labels"
   - Test: "All dialogs have aria-labelledby"
   - Test: "All close buttons have aria-label"
   - Test: "All interactive SVG elements have roles"

Commit: "fix(a11y): audit and fix ARIA labels across components"
```

---

### Prompt 4.4 — Color Contrast Verification

**Status:** ⬜ Pending
**Dependencies:** 0.2
**Priority:** P1

```text
Verify and fix color contrast to meet WCAG AA standards.

1. Document required contrast ratios:

   WCAG AA requirements:
   - Normal text: 4.5:1 minimum
   - Large text (18px+ or 14px+ bold): 3:1 minimum
   - UI components and graphics: 3:1 minimum

2. Test current color combinations:

   Use WebAIM Contrast Checker or similar tool.

   Combinations to verify:
   | Element         | Foreground       | Background       | Required |
   |-----------------|------------------|------------------|----------|
   | Body text       | --colour-text    | --colour-bg      | 4.5:1    |
   | Muted text      | --colour-text-muted | --colour-bg   | 4.5:1    |
   | Button text     | --colour-text    | --colour-surface | 4.5:1    |
   | Focus ring      | --colour-focus-ring | --colour-bg   | 3:1      |
   | Error text      | --colour-error   | --colour-surface | 4.5:1    |
   | Link text       | --colour-selection | --colour-bg    | 4.5:1    |
   | Placeholder     | (placeholder color) | --colour-surface | 4.5:1 |

3. Fix any failing combinations:

   Update src/lib/styles/tokens.css as needed:
   - If muted text fails, darken/lighten as appropriate
   - If placeholder fails, adjust to meet contrast
   - If error text fails, use a more saturated red

4. Add contrast-safe utilities:

   .text-high-contrast {
     color: var(--colour-text);
   }

   .text-medium-contrast {
     color: var(--colour-text-muted);
   }

   /* Use for decorative/non-essential text only */
   .text-low-contrast {
     color: var(--colour-text-disabled);
   }

5. Update light theme if needed:

   Verify light theme tokens also pass contrast tests.

6. Write tests in src/tests/contrast.test.ts:
   - Test: "Body text meets 4.5:1 contrast ratio"
   - Test: "Muted text meets 4.5:1 contrast ratio"
   - Test: "Error text meets 4.5:1 contrast ratio"
   - Test: "Focus indicators meet 3:1 contrast ratio"
   - Test: "Light theme colors meet contrast requirements"

Commit: "fix(a11y): verify and fix color contrast for WCAG AA"
```

---

## Phase 5: Visual Polish

### Prompt 5.1 — Edit Panel Visual Hierarchy

**Status:** ⬜ Pending
**Dependencies:** 2.2
**Priority:** P2

```text
Improve Edit Panel visual hierarchy and organization.

1. Update src/lib/components/EditPanel.svelte:

   Add contextual title:
   let title = $derived(() => {
     if ($selectedType === 'rack') {
       const rack = $racks.find(r => r.id === $selectedId);
       return `Edit: ${rack?.name ?? 'Rack'}`;
     }
     if ($selectedType === 'device') {
       const device = getSelectedDevice();
       return `Edit: ${device?.name ?? 'Device'}`;
     }
     return 'Edit';
   });

   Organize into sections:

   <div class="edit-panel">
     <DrawerHeader title={title} on:close={clearSelection} />

     <div class="edit-panel-content">
       {#if $selectedType === 'rack'}
         <!-- Properties Section -->
         <section class="edit-section">
           <h3 class="edit-section-title">Properties</h3>
           <!-- name input, height input -->
         </section>

         <!-- Information Section -->
         <section class="edit-section">
           <h3 class="edit-section-title">Information</h3>
           <!-- position, device count, capacity -->
         </section>

         <!-- Danger Zone -->
         <section class="edit-section edit-section-danger">
           <button class="button-destructive">Delete Rack</button>
         </section>
       {/if}
     </div>
   </div>

2. Add height preset buttons:

   <div class="preset-buttons">
     {#each [12, 18, 24, 42] as preset}
       <button
         class="preset-button"
         class:active={rackHeight === preset}
         disabled={hasDevices}
         on:click={() => setRackHeight(preset)}
       >
         {preset}U
       </button>
     {/each}
   </div>

3. Add section styles to app.css:

   .edit-panel-content {
     flex: 1;
     overflow-y: auto;
     padding: var(--space-4);
   }

   .edit-section {
     padding-bottom: var(--space-4);
     margin-bottom: var(--space-4);
     border-bottom: 1px solid var(--colour-border);
   }

   .edit-section:last-child {
     border-bottom: none;
     margin-bottom: 0;
   }

   .edit-section-title {
     font-size: var(--font-size-xs);
     font-weight: var(--font-weight-semibold);
     text-transform: uppercase;
     letter-spacing: 0.05em;
     color: var(--colour-text-muted);
     margin-bottom: var(--space-3);
   }

   .edit-section-danger {
     margin-top: auto;
     padding-top: var(--space-4);
     border-top: 1px solid var(--colour-error);
     border-bottom: none;
   }

   .button-destructive {
     display: flex;
     align-items: center;
     justify-content: center;
     gap: var(--space-2);
     width: 100%;
     padding: var(--space-3);
     border: 1px solid var(--colour-error);
     border-radius: var(--radius-md);
     background: transparent;
     color: var(--colour-error);
     cursor: pointer;
     transition: all var(--duration-fast) var(--ease-out);
   }

   .button-destructive:hover {
     background-color: var(--colour-error);
     color: white;
   }

4. Write tests in src/tests/EditPanelLayout.test.ts:
   - Test: "Edit panel shows contextual title"
   - Test: "Sections are visually separated"
   - Test: "Preset buttons show active state"
   - Test: "Delete button is in danger zone"
   - Test: "Info section shows capacity stats"

Commit: "feat(ui): improve Edit Panel visual hierarchy"
```

---

### Prompt 5.2 — Rack Visual Enhancements

**Status:** ⬜ Pending
**Dependencies:** 0.2
**Priority:** P2

```text
Enhance rack visual appearance with subtle improvements.

1. Add alternating row shading to src/lib/components/Rack.svelte:

   {#each Array(rack.height) as _, i}
     {@const uPosition = rack.height - i}
     {@const isEven = uPosition % 2 === 0}

     <rect
       class="u-slot-bg"
       class:even={isEven}
       x={RAIL_WIDTH}
       y={i * uHeight}
       width={rackWidth - RAIL_WIDTH * 2}
       height={uHeight}
     />
   {/each}

2. Highlight every 5th U number:

   <text
     class="u-number"
     class:highlight={uPosition % 5 === 0}
     x={RAIL_WIDTH / 2}
     y={i * uHeight + uHeight / 2}
     text-anchor="middle"
     dominant-baseline="middle"
   >
     {uPosition}
   </text>

3. Position rack title above rack:

   <text
     class="rack-title"
     x={rackWidth / 2}
     y={-12}
     text-anchor="middle"
   >
     {rack.name}
   </text>

4. Add CSS for rack enhancements:

   .u-slot-bg {
     fill: var(--rack-slot);
   }

   .u-slot-bg.even {
     fill: var(--rack-slot-alt);
   }

   .u-number {
     font-size: 10px;
     font-family: var(--font-mono, monospace);
     font-variant-numeric: tabular-nums;
     fill: var(--colour-text-muted);
     user-select: none;
   }

   .u-number.highlight {
     font-weight: var(--font-weight-semibold);
     fill: var(--colour-text);
   }

   .rack-title {
     font-size: var(--font-size-sm);
     font-weight: var(--font-weight-semibold);
     fill: var(--colour-text);
   }

5. Write tests in src/tests/RackVisuals.test.ts:
   - Test: "U slots have alternating shading"
   - Test: "Every 5th U number is highlighted"
   - Test: "Rack title is above the rack"
   - Test: "U numbers use tabular figures"

Commit: "feat(ui): enhance rack visual appearance"
```

---

## Phase 6: Animation System

### Prompt 6.1 — Animation Keyframes

**Status:** ⬜ Pending
**Dependencies:** 0.2
**Priority:** P2

```text
Create consistent animation system with keyframes.

1. Add animation keyframes to src/app.css:

   /* Device Drop Animation */
   @keyframes device-settle {
     0% {
       transform: scale(1.05);
       opacity: 0.8;
     }
     100% {
       transform: scale(1);
       opacity: 1;
     }
   }

   .device-just-dropped {
     animation: device-settle var(--duration-normal) var(--ease-spring);
   }

   /* Drawer Slide Animation */
   @keyframes drawer-slide-in-left {
     from { transform: translateX(-100%); }
     to { transform: translateX(0); }
   }

   @keyframes drawer-slide-in-right {
     from { transform: translateX(100%); }
     to { transform: translateX(0); }
   }

   .drawer-left {
     animation: drawer-slide-in-left var(--duration-normal) var(--ease-out);
   }

   .drawer-right {
     animation: drawer-slide-in-right var(--duration-normal) var(--ease-out);
   }

   /* Toast Animation */
   @keyframes toast-slide-up {
     from {
       transform: translateY(100%);
       opacity: 0;
     }
     to {
       transform: translateY(0);
       opacity: 1;
     }
   }

   .toast-enter {
     animation: toast-slide-up var(--duration-normal) var(--ease-out);
   }

   /* Dialog Fade */
   @keyframes dialog-fade-in {
     from { opacity: 0; }
     to { opacity: 1; }
   }

   @keyframes dialog-scale-in {
     from {
       transform: scale(0.95);
       opacity: 0;
     }
     to {
       transform: scale(1);
       opacity: 1;
     }
   }

   .dialog-backdrop {
     animation: dialog-fade-in var(--duration-fast) var(--ease-out);
   }

   .dialog {
     animation: dialog-scale-in var(--duration-normal) var(--ease-out);
   }

   /* Selection Pulse */
   @keyframes selection-pulse {
     0%, 100% { opacity: 0.5; }
     50% { opacity: 1; }
   }

   /* Shake (for errors) */
   @keyframes shake {
     0%, 100% { transform: translateX(0); }
     25% { transform: translateX(-4px); }
     75% { transform: translateX(4px); }
   }

   .error-shake {
     animation: shake var(--duration-normal) var(--ease-out);
   }

2. Write tests in src/tests/animations.test.ts:
   - Test: "Animation keyframes are defined"
   - Test: "Animation classes apply correctly"
   - Test: "Device settle animation plays on drop"

Commit: "feat(animation): add consistent animation keyframes"
```

---

### Prompt 6.2 — Reduced Motion Support

**Status:** ⬜ Pending
**Dependencies:** 6.1
**Priority:** P2

```text
Add support for prefers-reduced-motion media query.

1. Add reduced motion styles to src/app.css:

   @media (prefers-reduced-motion: reduce) {
     *,
     *::before,
     *::after {
       animation-duration: 0.01ms !important;
       animation-iteration-count: 1 !important;
       transition-duration: 0.01ms !important;
       scroll-behavior: auto !important;
     }
   }

2. Create motion preference utility in src/lib/utils/motion.ts:

   /**
    * Check if user prefers reduced motion.
    */
   export function prefersReducedMotion(): boolean {
     if (typeof window === 'undefined') return false;
     return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
   }

   /**
    * Get appropriate animation duration based on preference.
    */
   export function getAnimationDuration(normalDuration: number): number {
     return prefersReducedMotion() ? 0 : normalDuration;
   }

   /**
    * Svelte action for animations that respect motion preference.
    */
   export function animate(
     node: HTMLElement,
     { animation, duration = 200 }: { animation: string; duration?: number }
   ) {
     if (prefersReducedMotion()) {
       return {};
     }

     node.style.animation = `${animation} ${duration}ms`;

     return {
       destroy() {
         node.style.animation = '';
       }
     };
   }

3. Update components to use motion-aware animations:

   In Drawer.svelte:
   import { prefersReducedMotion } from '$lib/utils/motion';

   let shouldAnimate = !prefersReducedMotion();

   <div class="drawer" class:animate={shouldAnimate}>

4. Update any JavaScript animations:

   In RackDevice.svelte (if using JS animations):
   const duration = getAnimationDuration(200);
   // Use duration for any programmatic animations

5. Write tests in src/tests/reducedMotion.test.ts:
   - Test: "Animations disabled when prefers-reduced-motion"
   - Test: "prefersReducedMotion returns boolean"
   - Test: "getAnimationDuration returns 0 when reduced motion"
   - Test: "CSS respects reduced motion media query"

Commit: "feat(a11y): add prefers-reduced-motion support"
```

---

## Phase 7: Final Integration

### Prompt 7.1 — Visual Consistency Audit

**Status:** ⬜ Pending
**Dependencies:** All previous prompts
**Priority:** P2

```text
Audit visual consistency across all components.

1. Create visual consistency checklist:

   Spacing:
   - [ ] All padding uses --space-* tokens
   - [ ] All margins use --space-* tokens
   - [ ] All gaps use --space-* tokens
   - [ ] Consistent spacing between sections

   Colors:
   - [ ] All colors use --colour-* tokens
   - [ ] No hardcoded hex values
   - [ ] Consistent use of semantic colors
   - [ ] Light/dark themes both work

   Typography:
   - [ ] All font sizes use --font-size-* tokens
   - [ ] All font weights use --font-weight-* tokens
   - [ ] Consistent heading hierarchy

   Borders/Shadows:
   - [ ] All border radii use --radius-* tokens
   - [ ] All shadows use --shadow-* tokens
   - [ ] Consistent border colors

   Animation:
   - [ ] All transitions use --duration-* tokens
   - [ ] All easing uses --ease-* tokens
   - [ ] Reduced motion respected

2. Run visual regression:

   Capture screenshots of:
   - Empty state
   - Single rack
   - Multiple racks
   - Device library open
   - Edit panel with rack selected
   - Edit panel with device selected
   - Dialog open
   - Toast visible
   - Light theme
   - Dark theme

3. Fix any inconsistencies found.

4. Write tests in src/tests/visualConsistency.test.ts:
   - Test: "All components use design tokens"
   - Test: "No hardcoded colors in stylesheets"
   - Test: "Theme switching applies to all components"
   - Test: "Spacing is consistent (4px grid)"

Commit: "fix(ui): audit and fix visual consistency"
```

---

### Prompt 7.2 — Final Testing and Documentation

**Status:** ⬜ Pending
**Dependencies:** 7.1
**Priority:** P2

```text
Final testing pass and documentation for v0.2.1 release.

1. Run full test suite:
   npm run test:run

2. Run Lighthouse accessibility audit:
   - Target: Accessibility > 95
   - Fix any issues found

3. Cross-check all success criteria:

   From design-review-spec.md:
   - [ ] Each device library item displays grip handle
   - [ ] Cursor changes to grab on hover, grabbing during drag
   - [ ] Items lift slightly on hover with subtle shadow
   - [ ] Items scale up slightly when grabbed
   - [ ] Drop zones highlight during drag (blue for valid, red for invalid)
   - [ ] Multi-U devices highlight ALL affected slots
   - [ ] Ghost outline shows exact landing position
   - [ ] All toolbar buttons have: rest, hover, focus, active, disabled states
   - [ ] All inputs have: rest, hover, focus, invalid, disabled states
   - [ ] Selected rack has clear blue outline
   - [ ] Selected device has prominent selection indicator
   - [ ] Focus states visible and meet WCAG 2.4.7
   - [ ] Every toolbar icon has a tooltip
   - [ ] Tooltips show keyboard shortcut where applicable
   - [ ] Edit panel title shows "Edit: [Item Name]"
   - [ ] U slots have subtle alternating shading
   - [ ] Every 5th U number is visually highlighted
   - [ ] Devices have settle animation on drop
   - [ ] Drawers slide in/out smoothly
   - [ ] All animations respect prefers-reduced-motion
   - [ ] All buttons have aria-label or visible text
   - [ ] All dialogs trap focus and restore on close
   - [ ] Color contrast meets WCAG AA (4.5:1 for text, 3:1 for UI)
   - [ ] All design tokens in single organized file
   - [ ] No hardcoded color values in component styles

4. Update documentation:
   - Update CHANGELOG with v0.2.1 entry
   - Update version number in package.json

5. Code cleanup:
   - Remove console.log statements
   - Remove TODO comments (or document)
   - No TypeScript errors
   - No linting warnings

6. Final commit:

Commit: "chore: v0.2.1 release preparation"
```

---

## Progress Tracker

| Phase                      | Prompts            | Status |
| -------------------------- | ------------------ | ------ |
| 0. Design Token Foundation | 0.1, 0.2           | ⬜     |
| 1. Drag Affordance         | 1.1, 1.2, 1.3      | ⬜     |
| 2. Interaction States      | 2.1, 2.2, 2.3      | ⬜     |
| 3. Tooltip System          | 3.1, 3.2           | ⬜     |
| 4. Accessibility           | 4.1, 4.2, 4.3, 4.4 | ⬜     |
| 5. Visual Polish           | 5.1, 5.2           | ⬜     |
| 6. Animation System        | 6.1, 6.2           | ⬜     |
| 7. Final Integration       | 7.1, 7.2           | ⬜     |

**Total Prompts:** 18
**Estimated Time:** 4-6 hours with Claude Code

---

## Dependency Graph

```
0.1 Design Tokens
 └── 0.2 Token Migration
      ├── 1.1 Grip Icon
      │    └── 1.2 Palette Item Affordance
      │         └── 1.3 Drop Zone Highlighting
      │
      ├── 2.1 Toolbar Button States
      │    ├── 2.2 Form Input States
      │    │    └── 2.3 Selection States
      │    │
      │    └── 3.1 Tooltip Component
      │         └── 3.2 Toolbar Tooltips
      │
      ├── 4.1 Focus Utilities
      │    └── 4.2 Dialog Accessibility
      │         └── 4.3 ARIA Labels Audit
      │
      ├── 4.4 Color Contrast
      │
      ├── 5.1 Edit Panel Hierarchy
      │
      └── 5.2 Rack Visuals
           │
           └── 6.1 Animation Keyframes
                └── 6.2 Reduced Motion
                     │
                     └── 7.1 Visual Audit
                          └── 7.2 Final Testing
```

---

## Execution Notes

### Before Starting

1. Ensure v0.2 is complete and stable
2. Verify all v0.2 tests pass
3. Have design-review-spec.md open for reference
4. Have design-methodology.md open for detailed guidance

### During Execution

1. Write tests FIRST (TDD)
2. Run tests after each change
3. Commit after each successful prompt
4. Mark prompts complete in this file
5. Use design tokens consistently

### Key Technical Decisions

1. **Tokens first** — Foundation enables consistent implementation
2. **P0 before P1** — Critical usability issues before polish
3. **Accessibility integrated** — Not bolted on after
4. **Progressive enhancement** — Visual improvements don't break functionality
5. **Reduced motion support** — Accessibility from the start

### If Stuck

1. Re-read the design-review-spec.md section
2. Check design-methodology.md for detailed guidance
3. Test on real hardware if visual issues unclear
4. Use browser devtools to inspect computed styles
5. Verify tokens are applied correctly

### Quality Gates (Pre-commit)

- ESLint must pass
- Prettier formatting applied
- All tests must pass
- No TypeScript errors
- Lighthouse accessibility > 95
- No hardcoded color values

---

_Generated following Harper Reed LLM Codegen Methodology_
_Implements design-review-spec.md recommendations_
