---
created: 2025-11-30
updated: 2025-11-30
status: ready
version: 0.3.0
---

# Rackarr ‚Äî Prompt Plan (v0.3)

**Generated:** 2025-11-30
**Spec Version:** 0.3.0 (Mobile & PWA)
**Methodology:** Harper Reed LLM Codegen (TDD)
**Framework:** Svelte 5 with Runes
**Builds On:** v0.2.0 (Multi-View & Polish)

---

## Overview

This plan breaks down the Rackarr v0.3 MVP into **24 incremental, test-driven prompts** organised into **8 phases**. Each prompt builds on the previous with explicit dependencies ‚Äî no orphaned code.

**Key Principles:**

- Svelte 5 runes (`$state`, `$derived`, `$effect`) throughout
- Tests written first with explicit test case names
- Mobile-first responsive design
- Progressive enhancement (touch features layer on mouse/keyboard)
- Desktop experience remains unchanged

**v0.3 Goals:**

- Full mobile phone support (create/edit layouts)
- Two-tap device placement paradigm
- Touch gestures via Hammer.js
- Progressive Web App (installable, offline)
- Responsive layout with bottom sheets

---

## Phase 0: Foundation & Platform Detection

### Prompt 0.1 ‚Äî Platform Detection Utilities

**Status:** ‚¨ú Pending
**Dependencies:** None (builds on v0.2 codebase)

```text
Create platform detection utilities to determine interaction mode and device capabilities.

1. Create src/lib/utils/platform.ts with:

   PlatformCapabilities interface:
   - hasTouch: boolean
   - hasMouse: boolean
   - hasKeyboard: boolean
   - screenWidth: number
   - screenHeight: number
   - isStandalone: boolean (PWA installed mode)
   - prefersReducedMotion: boolean

   InteractionMode type:
   - 'desktop' | 'mobile' | 'hybrid'

   detectPlatform(): PlatformCapabilities
   - Use feature detection (not user-agent sniffing)
   - Check 'ontouchstart' in window
   - Check navigator.maxTouchPoints
   - Check window.matchMedia('(pointer: fine)') for mouse
   - Check display-mode: standalone for PWA

   getInteractionMode(capabilities: PlatformCapabilities): InteractionMode
   - 'desktop': hasMouse && !hasTouch
   - 'mobile': hasTouch && !hasMouse
   - 'hybrid': hasTouch && hasMouse (tablet with mouse)

   isMobileViewport(): boolean
   - Returns true if viewport width < 768px

   isPhoneViewport(): boolean
   - Returns true if viewport width < 480px

2. Create src/lib/stores/platform.svelte.ts:

   State ($state):
   - capabilities: PlatformCapabilities
   - interactionMode: InteractionMode
   - viewportWidth: number
   - viewportHeight: number

   Derived ($derived):
   - isMobile: viewportWidth < 768
   - isPhone: viewportWidth < 480
   - isDesktop: viewportWidth >= 1024
   - isTablet: viewportWidth >= 768 && viewportWidth < 1024
   - supportsTouch: capabilities.hasTouch

   Effects ($effect):
   - Listen to window resize, update viewport dimensions (debounced 100ms)
   - Listen to matchMedia changes for interaction mode updates

3. Write tests in src/tests/platform.test.ts:
   - Test: "detectPlatform returns hasTouch true when touch events available"
   - Test: "detectPlatform returns hasMouse true when pointer: fine matches"
   - Test: "getInteractionMode returns 'desktop' for mouse-only device"
   - Test: "getInteractionMode returns 'mobile' for touch-only device"
   - Test: "getInteractionMode returns 'hybrid' for touch+mouse device"
   - Test: "isMobileViewport returns true for width < 768"
   - Test: "isPhoneViewport returns true for width < 480"
   - Test: "platform store updates on viewport resize"

Commit: "feat(platform): add platform detection utilities and store"
```

---

### Prompt 0.2 ‚Äî CSS Breakpoints and Responsive Foundation

**Status:** ‚¨ú Pending
**Dependencies:** 0.1

```text
Add CSS custom properties and media query foundation for responsive design.

1. Update src/app.css with responsive breakpoints:

   Add to :root:
   --breakpoint-phone: 480px
   --breakpoint-tablet: 768px
   --breakpoint-desktop: 1024px

   --touch-target-min: 48px (minimum touch target size)
   --mobile-toolbar-height: 56px
   --mobile-bottom-sheet-handle: 32px
   --mobile-rack-navigator-height: 48px

2. Add media query mixins as CSS comments (for reference):

   /* Phone portrait: max-width: 479px */
   /* Phone landscape / small tablet: 480px - 767px */
   /* Tablet portrait: 768px - 1023px */
   /* Desktop: min-width: 1024px */

3. Add utility classes in app.css:

   .mobile-only { display: none; }
   .desktop-only { display: block; }

   @media (max-width: 767px) {
     .mobile-only { display: block; }
     .desktop-only { display: none; }
   }

   .touch-target {
     min-height: var(--touch-target-min);
     min-width: var(--touch-target-min);
   }

4. Update existing fixed dimensions to use CSS custom properties:
   - toolbar-height already exists, ensure mobile variant works
   - drawer-width already exists

5. Add safe area support for notched devices:

   @supports (padding-top: env(safe-area-inset-top)) {
     :root {
       --safe-area-top: env(safe-area-inset-top);
       --safe-area-bottom: env(safe-area-inset-bottom);
       --safe-area-left: env(safe-area-inset-left);
       --safe-area-right: env(safe-area-inset-right);
     }
   }

6. Write tests in src/tests/responsive.test.ts:
   - Test: "CSS custom properties are defined for breakpoints"
   - Test: "mobile-only class hidden on desktop viewport"
   - Test: "desktop-only class hidden on mobile viewport"
   - Test: "touch-target class applies minimum dimensions"

Commit: "feat(css): add responsive breakpoints and utility classes"
```

---

## Phase 1: Responsive Toolbar

### Prompt 1.1 ‚Äî Compact Mobile Toolbar

**Status:** ‚¨ú Pending
**Dependencies:** 0.2

```text
Create a responsive toolbar that adapts to mobile viewports.

1. Update src/lib/components/Toolbar.svelte:

   Import platform store to detect viewport size.

   Desktop layout (‚â•768px): Keep existing layout unchanged

   Mobile layout (<768px):
   - Height: 56px (var(--mobile-toolbar-height))
   - Left: Rackarr icon only (opens menu sheet)
   - Center: Current rack name (truncated, tappable to edit)
   - Right: More menu button (‚ãÆ) that opens action sheet

   Remove from mobile toolbar (move to menu):
   - Device Library toggle (handled by bottom sheet)
   - Zoom controls (use pinch gesture)
   - Theme toggle
   - Individual action buttons

   Keep on mobile toolbar:
   - Menu icon (hamburger or Rackarr icon)
   - Rack name display
   - View toggle (Front/Rear) if v0.2 rear view enabled
   - More menu (‚ãÆ)

2. Create src/lib/components/MobileMenuSheet.svelte:

   Props:
   - open: boolean

   Full-height slide-up sheet containing:
   - "New Rack" button
   - "Save Layout" button
   - "Load Layout" button
   - "Export" button
   - Divider
   - "Theme" toggle (Dark/Light with current state)
   - "Help & About" link
   - App version at bottom

   Events:
   - dispatch('close')
   - dispatch('action', { action: 'newRack' | 'save' | 'load' | 'export' | 'help' })

   Styling:
   - Backdrop overlay (semi-transparent)
   - Slide animation from bottom
   - Close on backdrop tap or swipe down

3. Update Toolbar.svelte to conditionally render:

   {#if $isMobile}
     <MobileToolbar />
   {:else}
     <!-- existing desktop toolbar -->
   {/if}

4. Write tests in src/tests/MobileToolbar.test.ts:
   - Test: "Mobile toolbar renders on viewport < 768px"
   - Test: "Desktop toolbar renders on viewport >= 768px"
   - Test: "Mobile toolbar shows rack name truncated"
   - Test: "More menu button opens action sheet"
   - Test: "Menu sheet contains all action buttons"
   - Test: "Menu sheet closes on backdrop tap"
   - Test: "Menu sheet dispatches correct action events"

Commit: "feat(toolbar): add responsive mobile toolbar with menu sheet"
```

---

### Prompt 1.2 ‚Äî Mobile Action Sheet Component

**Status:** ‚¨ú Pending
**Dependencies:** 1.1

```text
Create a reusable action sheet component for mobile interactions.

1. Create src/lib/components/ActionSheet.svelte:

   Props:
   - open: boolean
   - title?: string
   - actions: Array<{ id: string, label: string, icon?: Component, destructive?: boolean }>

   Features:
   - Slides up from bottom
   - Backdrop overlay
   - Handle bar at top for swipe gesture
   - List of action buttons
   - Destructive actions styled in red
   - Cancel button at bottom (always present)

   Accessibility:
   - role="dialog"
   - aria-modal="true"
   - Focus trap when open
   - Escape closes

   Events:
   - dispatch('select', { actionId: string })
   - dispatch('cancel')
   - dispatch('close')

   Animation:
   - Slide up: 200ms ease-out
   - Slide down: 150ms ease-in
   - Respect prefers-reduced-motion

2. Create src/lib/components/SheetHandle.svelte:

   Visual handle bar for sheets:
   - 40px wide, 4px tall, rounded
   - Centered horizontally
   - Subtle color (--colour-border)

3. Update MobileMenuSheet to use ActionSheet as base.

4. Write tests in src/tests/ActionSheet.test.ts:
   - Test: "ActionSheet renders when open=true"
   - Test: "ActionSheet hidden when open=false"
   - Test: "ActionSheet shows all provided actions"
   - Test: "Clicking action dispatches select event with actionId"
   - Test: "Cancel button dispatches cancel event"
   - Test: "Backdrop tap dispatches close event"
   - Test: "Destructive actions have red styling"
   - Test: "Escape key closes action sheet"

Commit: "feat(components): add ActionSheet component for mobile"
```

---

## Phase 2: Bottom Sheet System

### Prompt 2.1 ‚Äî Bottom Sheet Base Component

**Status:** ‚¨ú Pending
**Dependencies:** 1.2

```text
Create the bottom sheet component that replaces side drawers on mobile.

1. Create src/lib/components/BottomSheet.svelte:

   Props:
   - open: boolean
   - state: 'collapsed' | 'half' | 'expanded' | 'hidden'
   - collapsedHeight: number (default: 80)
   - halfHeight: string (default: '40vh')
   - expandedHeight: string (default: '90vh')
   - title?: string

   Features:
   - Three visible states plus hidden
   - Swipe up/down to change states
   - Tap handle to toggle collapsed/half
   - Smooth spring animation between states
   - Content scrollable when expanded

   Visual structure:
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ  ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê    ‚îÇ  ‚Üê Handle bar
   ‚îÇ  Title (optional)       ‚îÇ
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
   ‚îÇ                         ‚îÇ
   ‚îÇ  <slot /> (content)     ‚îÇ
   ‚îÇ                         ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

   Gesture handling (prep for Hammer.js):
   - Track touch start/move/end
   - Calculate velocity for momentum
   - Snap to nearest state based on position + velocity

   Events:
   - dispatch('statechange', { state })

   CSS:
   - position: fixed
   - bottom: 0
   - left: 0, right: 0
   - border-radius: 16px 16px 0 0 (top corners)
   - box-shadow for elevation
   - z-index above canvas, below modals

2. Create src/lib/utils/gestures.ts (basic, pre-Hammer):

   calculateSnapState(currentY, velocity, states): state
   - Determine which state to snap to based on position and swipe velocity

   Basic touch tracking utilities:
   - getSwipeVelocity(startY, endY, duration): number
   - getSwipeDirection(startY, endY): 'up' | 'down' | 'none'

3. Write tests in src/tests/BottomSheet.test.ts:
   - Test: "BottomSheet renders in collapsed state by default"
   - Test: "BottomSheet shows correct height for collapsed state"
   - Test: "BottomSheet shows correct height for half state"
   - Test: "BottomSheet shows correct height for expanded state"
   - Test: "BottomSheet hidden when state is 'hidden'"
   - Test: "Handle tap toggles between collapsed and half"
   - Test: "State change dispatches statechange event"
   - Test: "Content is scrollable in expanded state"

Commit: "feat(components): add BottomSheet component"
```

---

### Prompt 2.2 ‚Äî Device Library Bottom Sheet

**Status:** ‚¨ú Pending
**Dependencies:** 2.1

```text
Create the mobile Device Library as a bottom sheet, replacing the side drawer on mobile.

1. Create src/lib/components/DeviceLibrarySheet.svelte:

   Wraps BottomSheet with Device Library content.

   Props:
   - open: boolean (from ui store)

   State:
   - sheetState: 'collapsed' | 'half' | 'expanded'
   - searchQuery: string
   - selectedDeviceId: string | null (for two-tap placement)

   Collapsed view (80px):
   - Handle bar
   - "Device Library" title
   - Device count badge

   Half view (40vh):
   - Search field
   - Scrollable device list (categories collapsed)
   - "Add Device" button

   Expanded view (90vh):
   - Full device list with expanded categories
   - Import button

   Device selection for placement:
   - Tap device ‚Üí sets selectedDeviceId
   - Device shows "selected" state (checkmark, highlight)
   - Toast appears: "Tap a U position to place [name]"
   - Sheet auto-collapses to show canvas

2. Create src/lib/components/DeviceLibraryItem.svelte:

   Mobile-optimized device list item:
   - Min height: 48px (touch target)
   - Category icon (24px)
   - Device name (truncated)
   - Height badge ("2U")
   - Selected state indicator

   Events:
   - dispatch('select', { deviceId })

3. Update src/lib/stores/ui.svelte.ts:

   Add mobile-specific state:
   - deviceLibrarySheetState: 'collapsed' | 'half' | 'expanded' | 'hidden'
   - selectedLibraryDevice: string | null (for two-tap placement)

   Actions:
   - setDeviceLibrarySheetState(state)
   - selectLibraryDeviceForPlacement(deviceId)
   - clearLibraryDeviceSelection()

4. Update App.svelte:

   Conditionally render based on platform:
   {#if $isMobile}
     <DeviceLibrarySheet />
   {:else}
     <Drawer side="left">
       <DevicePalette />
     </Drawer>
   {/if}

5. Write tests in src/tests/DeviceLibrarySheet.test.ts:
   - Test: "Sheet renders in collapsed state showing title and count"
   - Test: "Sheet shows search field in half state"
   - Test: "Sheet shows full device list in expanded state"
   - Test: "Tapping device selects it for placement"
   - Test: "Selected device shows visual indicator"
   - Test: "Selection auto-collapses sheet"
   - Test: "Search filters device list"

Commit: "feat(mobile): add Device Library bottom sheet"
```

---

### Prompt 2.3 ‚Äî Edit Panel Bottom Sheet

**Status:** ‚¨ú Pending
**Dependencies:** 2.2

```text
Create the mobile Edit Panel as a modal bottom sheet.

1. Create src/lib/components/EditSheet.svelte:

   Modal sheet that appears when device or rack is selected on mobile.

   Props: none (reads from selection store)

   Behaviour:
   - Auto-opens when device/rack selected on mobile
   - Slides up from bottom (60-80% viewport)
   - Backdrop dims canvas
   - Close via: swipe down, tap backdrop, or explicit close

   Device editing contents:
   - Device name (read-only, shows library reference)
   - Position spinner (U number, editable)
   - Mounted Face: Front / Rear / Both (radio)
   - "Move to Rack" dropdown (if multiple racks)
   - "Remove from Rack" button (destructive, red)

   Rack editing contents:
   - Rack name (editable text input)
   - Height in U (editable with constraints)
   - Utilisation display (X of Y Us used)
   - "Duplicate Rack" button
   - "Delete Rack" button (destructive, red)

2. Create src/lib/components/PositionSpinner.svelte:

   Touch-friendly number input for U position:
   - Large minus/plus buttons (48px)
   - Current value display in center
   - Min/max constraints
   - Haptic feedback prep (vibration API)

   Props:
   - value: number
   - min: number
   - max: number
   - label: string

   Events:
   - dispatch('change', { value })

3. Update App.svelte to render EditSheet on mobile:

   {#if $isMobile && $hasSelection}
     <EditSheet />
   {:else if !$isMobile}
     <Drawer side="right">
       <EditPanel />
     </Drawer>
   {/if}

4. Write tests in src/tests/EditSheet.test.ts:
   - Test: "EditSheet opens when device selected on mobile"
   - Test: "EditSheet opens when rack selected on mobile"
   - Test: "EditSheet shows device properties when device selected"
   - Test: "EditSheet shows rack properties when rack selected"
   - Test: "Position spinner changes device position"
   - Test: "Remove button removes device from rack"
   - Test: "Swipe down closes sheet"
   - Test: "Backdrop tap closes sheet"

Commit: "feat(mobile): add Edit Panel bottom sheet"
```

---

## Phase 3: Mobile Canvas & Navigation

### Prompt 3.1 ‚Äî Rack Navigator Component

**Status:** ‚¨ú Pending
**Dependencies:** 2.3

```text
Create the rack navigation bar for mobile single-rack view.

1. Create src/lib/components/RackNavigator.svelte:

   Fixed bar above bottom sheet on mobile.

   Visual layout:
   ‚óÄ  Rack 1 of 3  ‚ñ∂  [+]

   Components:
   - Previous button (‚óÄ) ‚Äî disabled if first rack
   - Position indicator ("Rack X of Y")
   - Next button (‚ñ∂) ‚Äî disabled if last rack
   - Quick add button (+) ‚Äî opens new rack form

   Props: none (reads from layout store)

   State:
   - currentRackIndex: number (synced with visible rack)

   Events:
   - dispatch('navigate', { direction: 'prev' | 'next' })
   - dispatch('add')

   Styling:
   - Height: 48px
   - Background: var(--colour-surface)
   - Border top: 1px solid var(--colour-border)
   - Buttons: 48px touch targets

2. Create src/lib/stores/mobileNavigation.svelte.ts:

   State:
   - currentRackIndex: number (which rack is visible on mobile)

   Derived:
   - currentRack: Rack | null
   - canNavigatePrev: currentRackIndex > 0
   - canNavigateNext: currentRackIndex < racks.length - 1
   - rackCount: racks.length

   Actions:
   - navigateToRack(index: number)
   - navigatePrev()
   - navigateNext()
   - syncWithSelection() ‚Äî when rack selected, navigate to it

3. Update App.svelte mobile layout:

   Structure on mobile:
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ  Mobile Toolbar (56px)  ‚îÇ
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
   ‚îÇ                         ‚îÇ
   ‚îÇ  Canvas (single rack)   ‚îÇ
   ‚îÇ                         ‚îÇ
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
   ‚îÇ  Rack Navigator (48px)  ‚îÇ
   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
   ‚îÇ  Bottom Sheet           ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

4. Write tests in src/tests/RackNavigator.test.ts:
   - Test: "Navigator shows current rack position"
   - Test: "Previous button disabled on first rack"
   - Test: "Next button disabled on last rack"
   - Test: "Clicking next navigates to next rack"
   - Test: "Clicking prev navigates to previous rack"
   - Test: "Add button opens new rack form"
   - Test: "Position indicator updates on navigation"

Commit: "feat(mobile): add rack navigator component"
```

---

### Prompt 3.2 ‚Äî Single Rack Mobile View

**Status:** ‚¨ú Pending
**Dependencies:** 3.1

```text
Adapt the canvas to show a single rack on mobile viewports.

1. Update src/lib/components/Canvas.svelte:

   Add mobile view mode:
   - Desktop: Show all racks horizontally (existing behaviour)
   - Mobile: Show single rack, full width, centered

   Conditional rendering:
   {#if $isMobile}
     {#if currentRack}
       <SingleRackView rack={currentRack} />
     {:else}
       <MobileEmptyState />
     {/if}
   {:else}
     <!-- existing multi-rack canvas -->
   {/if}

2. Create src/lib/components/SingleRackView.svelte:

   Renders a single rack optimized for mobile:
   - Rack fills available width (with padding)
   - Vertical scroll if rack exceeds viewport
   - Centered horizontally
   - Touch events enabled for device placement

   Props:
   - rack: Rack

   Integration with panzoom:
   - Enable pinch-to-zoom
   - Double-tap to reset zoom
   - Disable pan (use swipe for rack navigation instead)

3. Create src/lib/components/MobileEmptyState.svelte:

   Empty state for mobile when no racks exist:
   - Centered message
   - "Create your first rack" prompt
   - Large "New Rack" button (primary)
   - "Load Layout" button (secondary)

4. Update Canvas.svelte touch handling:

   On mobile, canvas should:
   - Accept taps for device placement (two-tap flow)
   - Accept pinch for zoom
   - Pass swipe left/right to rack navigation
   - NOT drag-and-drop (mobile uses two-tap)

5. Write tests in src/tests/SingleRackView.test.ts:
   - Test: "SingleRackView renders rack full width on mobile"
   - Test: "SingleRackView shows correct rack from navigation"
   - Test: "Empty state shown when no racks exist"
   - Test: "Tapping U slot triggers placement when device selected"
   - Test: "Pinch gesture triggers zoom"
   - Test: "Double-tap resets zoom to fit"

Commit: "feat(mobile): add single rack mobile view"
```

---

## Phase 4: Touch Gesture System

### Prompt 4.1 ‚Äî Hammer.js Integration

**Status:** ‚¨ú Pending
**Dependencies:** 3.2

```text
Install and integrate Hammer.js for advanced touch gesture handling.

1. Install @egjs/hammerjs:
   npm install @egjs/hammerjs

2. Create src/lib/utils/hammer.ts:

   Type definitions for Hammer.js events:
   - HammerTapEvent
   - HammerPinchEvent
   - HammerPanEvent
   - HammerPressEvent

   setupCanvasGestures(element: HTMLElement, callbacks: GestureCallbacks): () => void
   - Initialize Hammer instance
   - Enable pinch recognizer (disabled by default)
   - Configure pan for horizontal rack navigation
   - Return cleanup function

   GestureCallbacks interface:
   - onTap?: (event: HammerTapEvent) => void
   - onDoubleTap?: (event: HammerTapEvent) => void
   - onPinch?: (event: HammerPinchEvent) => void
   - onPinchEnd?: (event: HammerPinchEvent) => void
   - onPanLeft?: (event: HammerPanEvent) => void
   - onPanRight?: (event: HammerPanEvent) => void
   - onPress?: (event: HammerPressEvent) => void

3. Create src/lib/actions/gestures.ts (Svelte action):

   use:gestures={{ onTap, onPinch, ... }}

   Svelte action that sets up Hammer.js on an element:
   - Initialize on mount
   - Cleanup on destroy
   - Update callbacks on parameter change

4. Update Canvas.svelte to use gesture action:

   <div
     class="canvas-container"
     use:gestures={{
       onTap: handleCanvasTap,
       onPinch: handlePinch,
       onPanLeft: () => navigateNext(),
       onPanRight: () => navigatePrev(),
       onDoubleTap: () => fitAll()
     }}
   >

5. Integrate with panzoom:

   Disable panzoom's built-in touch handling:
   panzoom(element, {
     smoothScroll: false,
     zoomDoubleClickSpeed: 1,
     beforeMouseDown: () => false,
     beforeTouch: () => false  // We handle via Hammer.js
   });

   Map Hammer pinch to panzoom:
   onPinch: (e) => {
     panzoomInstance.zoomTo(e.center.x, e.center.y, e.scale);
   }

6. Write tests in src/tests/hammer.test.ts:
   - Test: "setupCanvasGestures returns cleanup function"
   - Test: "Tap callback invoked on tap gesture"
   - Test: "Pinch callback invoked on pinch gesture"
   - Test: "Pan callbacks invoked on horizontal swipe"
   - Test: "Press callback invoked on long press"
   - Test: "Cleanup function removes event listeners"

Commit: "feat(gestures): integrate Hammer.js for touch handling"
```

---

### Prompt 4.2 ‚Äî Pinch-to-Zoom Integration

**Status:** ‚¨ú Pending
**Dependencies:** 4.1

```text
Implement pinch-to-zoom that integrates with the existing panzoom library.

1. Update src/lib/stores/canvas.svelte.ts:

   Add mobile zoom methods:
   - pinchZoom(scale: number, centerX: number, centerY: number): void
   - pinchZoomEnd(): void
   - doubleTapReset(): void

   Track pinch state:
   - isPinching: boolean
   - pinchStartZoom: number

2. Create src/lib/utils/pinchZoom.ts:

   calculatePinchZoom(startZoom, currentScale, minZoom, maxZoom): number
   - Apply pinch scale to starting zoom
   - Clamp to min/max bounds
   - Return new zoom level

   smoothZoomTo(panzoom, targetZoom, duration): Promise<void>
   - Animate zoom change over duration
   - Respect prefers-reduced-motion

3. Update SingleRackView.svelte:

   Handle pinch gestures:

   let pinchStartZoom = 1;

   function handlePinchStart(e: HammerPinchEvent) {
     pinchStartZoom = getCurrentZoom();
   }

   function handlePinch(e: HammerPinchEvent) {
     const newZoom = calculatePinchZoom(pinchStartZoom, e.scale, 0.25, 2);
     pinchZoom(newZoom, e.center.x, e.center.y);
   }

   function handlePinchEnd() {
     pinchZoomEnd();
   }

   function handleDoubleTap() {
     fitAll(); // Reset to fit rack in view
   }

4. Update gesture callbacks in canvas:

   use:gestures={{
     onPinchStart: handlePinchStart,
     onPinch: handlePinch,
     onPinchEnd: handlePinchEnd,
     onDoubleTap: handleDoubleTap,
     ...
   }}

5. Visual feedback during pinch:
   - Show zoom percentage indicator briefly
   - Smooth animation between pinch end and final position

6. Write tests in src/tests/pinchZoom.test.ts:
   - Test: "Pinch out increases zoom level"
   - Test: "Pinch in decreases zoom level"
   - Test: "Zoom clamped to minimum 25%"
   - Test: "Zoom clamped to maximum 200%"
   - Test: "Double-tap resets zoom to fit-all"
   - Test: "Pinch centers on gesture point"

Commit: "feat(zoom): implement pinch-to-zoom with panzoom integration"
```

---

### Prompt 4.3 ‚Äî Swipe Navigation Between Racks

**Status:** ‚¨ú Pending
**Dependencies:** 4.2

```text
Implement swipe left/right to navigate between racks on mobile.

1. Update src/lib/stores/mobileNavigation.svelte.ts:

   Add swipe navigation state:
   - isTransitioning: boolean
   - transitionDirection: 'left' | 'right' | null

   Actions:
   - swipeToNext(): animate transition, then navigate
   - swipeToPrev(): animate transition, then navigate

2. Update SingleRackView.svelte:

   Add swipe gesture handling:

   function handlePanLeft(e: HammerPanEvent) {
     if (e.isFinal && Math.abs(e.velocityX) > 0.3) {
       // Swipe was fast enough, navigate
       swipeToNext();
     }
   }

   function handlePanRight(e: HammerPanEvent) {
     if (e.isFinal && Math.abs(e.velocityX) > 0.3) {
       swipeToPrev();
     }
   }

3. Add transition animation:

   CSS for rack transition:
   .rack-container {
     transition: transform 200ms ease-out;
   }

   .rack-container.transitioning-left {
     transform: translateX(-100%);
   }

   .rack-container.transitioning-right {
     transform: translateX(100%);
   }

4. Add visual swipe feedback:

   During pan (before release):
   - Slight horizontal offset following finger
   - Edge peek of adjacent rack (if exists)
   - Resistance at edges (first/last rack)

   On release:
   - If velocity/distance sufficient: complete navigation
   - Otherwise: snap back to current rack

5. Prevent conflicts:
   - Disable swipe when pinch-zooming
   - Disable swipe when bottom sheet is expanded
   - Disable swipe when editing (EditSheet open)

6. Write tests in src/tests/swipeNavigation.test.ts:
   - Test: "Swipe left navigates to next rack"
   - Test: "Swipe right navigates to previous rack"
   - Test: "Slow swipe snaps back to current rack"
   - Test: "Swipe at first rack shows resistance"
   - Test: "Swipe at last rack shows resistance"
   - Test: "Navigation disabled during pinch"
   - Test: "Transition animation plays between racks"

Commit: "feat(navigation): implement swipe navigation between racks"
```

---

## Phase 5: Two-Tap Device Placement

### Prompt 5.1 ‚Äî Device Selection State

**Status:** ‚¨ú Pending
**Dependencies:** 4.3

```text
Implement the device selection state for two-tap placement flow.

1. Update src/lib/stores/ui.svelte.ts:

   Add placement state:

   type PlacementMode =
     | { mode: 'none' }
     | { mode: 'placing'; deviceId: string; deviceName: string }

   State:
   - placementMode: PlacementMode ($state)

   Derived:
   - isPlacingDevice: placementMode.mode === 'placing'
   - placingDeviceId: placementMode.mode === 'placing' ? placementMode.deviceId : null

   Actions:
   - startDevicePlacement(deviceId: string, deviceName: string): void
   - cancelDevicePlacement(): void
   - completePlacement(): void

2. Update DeviceLibrarySheet.svelte:

   When device tapped:
   1. Call startDevicePlacement(device.id, device.name)
   2. Show toast: "Tap a U position to place [name]"
   3. Auto-collapse sheet to show canvas
   4. Device item shows selected state (checkmark overlay)

   Selected device styling:
   .device-item.selected {
     background: var(--colour-selection-bg);
     border: 2px solid var(--colour-selection);
   }
   .device-item.selected::after {
     content: '‚úì';
     /* checkmark overlay */
   }

3. Update DeviceLibraryItem.svelte:

   Props:
   - device: Device
   - selected: boolean

   Styling:
   - Normal: Standard list item
   - Selected: Highlighted with checkmark

4. Cancel placement triggers:
   - Tap same device again ‚Üí deselect
   - Tap outside rack ‚Üí cancel
   - Press Escape ‚Üí cancel
   - Open menu ‚Üí cancel
   - Navigate to different rack ‚Üí keep selection (can place in new rack)

5. Write tests in src/tests/placementState.test.ts:
   - Test: "startDevicePlacement sets placing mode"
   - Test: "isPlacingDevice true when in placing mode"
   - Test: "Device shows selected state when being placed"
   - Test: "cancelDevicePlacement resets to none mode"
   - Test: "Tapping same device cancels placement"
   - Test: "Escape key cancels placement"
   - Test: "Selection persists across rack navigation"

Commit: "feat(placement): add device selection state for two-tap flow"
```

---

### Prompt 5.2 ‚Äî U Slot Tap Targets

**Status:** ‚¨ú Pending
**Dependencies:** 5.1

```text
Add tap targets to U slots for device placement on mobile.

1. Update src/lib/components/Rack.svelte:

   When in placement mode, render tap targets over empty U slots:

   {#if $isPlacingDevice && $isMobile}
     {#each emptyUSlots as slot}
       <USlotTarget
         uPosition={slot}
         rackId={rack.id}
         deviceHeight={placingDeviceHeight}
         valid={canPlaceAt(slot)}
         on:tap={handleUSlotTap}
       />
     {/each}
   {/if}

2. Create src/lib/components/USlotTarget.svelte:

   Invisible tap target with expanded hit area for U slots.

   Props:
   - uPosition: number
   - rackId: string
   - deviceHeight: number
   - valid: boolean

   Rendering:
   - Invisible rect covering U slot(s) that device would occupy
   - Extended tap area (U height is 22px, extend to ~48px)
   - Visual preview of where device would land

   Visual feedback:
   - Valid: Green tint on hover/focus
   - Invalid: Red tint, disabled state

   Events:
   - dispatch('tap', { uPosition, rackId })

3. Update Rack.svelte tap handling:

   function handleUSlotTap(event: { uPosition: number, rackId: string }) {
     if ($placementMode.mode === 'placing') {
       const success = placeDevice(
         event.rackId,
         $placementMode.deviceId,
         event.uPosition
       );

       if (success) {
         completePlacement();
         showToast('Device placed', 'success');
       } else {
         showToast('Cannot place here', 'error');
         // Keep in placement mode to try different position
       }
     }
   }

4. Add placement preview:

   When hovering/touching valid U slot:
   - Show ghost outline of device at that position
   - Ghost uses device color at 40% opacity
   - Shows device name

5. Write tests in src/tests/USlotTarget.test.ts:
   - Test: "U slot targets render when in placement mode"
   - Test: "Tap on valid slot places device"
   - Test: "Tap on invalid slot shows error"
   - Test: "Placement preview shows ghost device"
   - Test: "Touch target meets 48px minimum"
   - Test: "Multi-U device shows preview for all occupied slots"

Commit: "feat(placement): add U slot tap targets for device placement"
```

---

### Prompt 5.3 ‚Äî Placement Feedback and Animation

**Status:** ‚¨ú Pending
**Dependencies:** 5.2

```text
Add visual and haptic feedback for device placement.

1. Create src/lib/utils/haptics.ts:

   Haptic feedback utilities (using Vibration API):

   canVibrate(): boolean
   - Check if navigator.vibrate exists

   vibrate(pattern: number | number[]): void
   - Trigger vibration if available
   - No-op if not supported

   Haptic patterns:
   - HAPTIC_TAP: 10 (light tap)
   - HAPTIC_SUCCESS: [10, 50, 10] (success double tap)
   - HAPTIC_ERROR: [50, 50, 50] (error buzz)

2. Add placement success animation:

   When device placed successfully:
   1. Brief green flash on U slots
   2. Device "drops in" animation (scale from 1.1 to 1)
   3. Haptic success feedback
   4. Toast: "[Device] placed at U[position]"

   CSS animation:
   @keyframes device-place {
     from {
       transform: scale(1.1);
       opacity: 0.8;
     }
     to {
       transform: scale(1);
       opacity: 1;
     }
   }

   .device.just-placed {
     animation: device-place 150ms ease-out;
   }

3. Add placement error feedback:

   When placement fails (collision):
   1. Red flash on conflicting slots
   2. Shake animation on tap target
   3. Haptic error feedback
   4. Toast: "Position blocked by [conflicting device]"

   CSS animation:
   @keyframes shake {
     0%, 100% { transform: translateX(0); }
     25% { transform: translateX(-4px); }
     75% { transform: translateX(4px); }
   }

   .u-slot-target.error {
     animation: shake 200ms ease-out;
   }

4. Update USlotTarget.svelte:

   Add animation state:
   - justPlaced: boolean (triggers success animation)
   - error: boolean (triggers error animation)

5. Integrate haptics:

   In placement handler:
   if (success) {
     vibrate(HAPTIC_SUCCESS);
   } else {
     vibrate(HAPTIC_ERROR);
   }

6. Write tests in src/tests/placementFeedback.test.ts:
   - Test: "Success placement shows green flash"
   - Test: "Success placement triggers drop animation"
   - Test: "Error placement shows red flash"
   - Test: "Error placement triggers shake animation"
   - Test: "Haptic feedback called on placement"
   - Test: "Toast shown with device name and position"

Commit: "feat(feedback): add placement feedback animations and haptics"
```

---

### Prompt 5.4 ‚Äî Long-Press Drag Mode (Optional)

**Status:** ‚¨ú Pending
**Dependencies:** 5.3

```text
Add optional long-press drag mode for power users on mobile.

1. Update src/lib/components/RackDevice.svelte:

   Add long-press detection:

   use:gestures={{
     onPress: handleLongPress,  // 500ms hold
     onPanStart: handleDragStart,
     onPan: handleDrag,
     onPanEnd: handleDragEnd
   }}

   Long-press flow:
   1. User long-presses device (500ms)
   2. Device "lifts" with shadow (scale 1.05, shadow)
   3. Haptic feedback (HAPTIC_TAP)
   4. Device follows finger during pan
   5. Valid drop zones highlight
   6. Release to drop or cancel

2. Add drag state to selection store:

   State:
   - dragState: { isDragging: boolean; deviceId: string | null; sourcePosition: number }

   Actions:
   - startDrag(rackId: string, deviceId: string, position: number)
   - updateDragPosition(y: number)
   - endDrag(targetPosition: number | null)
   - cancelDrag()

3. Create mobile drag visual:

   .device.dragging {
     transform: scale(1.05);
     box-shadow: 0 8px 16px rgba(0,0,0,0.3);
     z-index: 100;
     pointer-events: none;
   }

   .device.drag-ghost {
     opacity: 0.3;
   }

4. Drop zone highlighting:

   During drag:
   - Valid positions: green outline
   - Invalid positions: red outline
   - Original position: dashed outline (ghost)

5. Handle drop:

   On pan end:
   - Calculate nearest valid U position
   - If valid: move device, success animation
   - If invalid: return to original, error feedback
   - If outside rack: cancel drag

6. Write tests in src/tests/mobileDrag.test.ts:
   - Test: "Long-press (500ms) initiates drag mode"
   - Test: "Short press does not initiate drag"
   - Test: "Device follows finger during drag"
   - Test: "Drop on valid position moves device"
   - Test: "Drop on invalid position returns to original"
   - Test: "Drag can be cancelled by moving outside rack"
   - Test: "Ghost shows at original position during drag"

Commit: "feat(mobile): add long-press drag mode for devices"
```

---

## Phase 6: PWA Infrastructure

### Prompt 6.1 ‚Äî Web App Manifest

**Status:** ‚¨ú Pending
**Dependencies:** 5.4

```text
Create the Progressive Web App manifest for installability.

1. Create public/manifest.json:

   {
     "name": "Rackarr",
     "short_name": "Rackarr",
     "description": "Rack layout designer for homelabbers",
     "start_url": "/",
     "display": "standalone",
     "background_color": "#1a1a1a",
     "theme_color": "#1a1a1a",
     "orientation": "any",
     "categories": ["utilities", "productivity"],
     "icons": [
       {
         "src": "/icons/icon-192.png",
         "sizes": "192x192",
         "type": "image/png",
         "purpose": "any maskable"
       },
       {
         "src": "/icons/icon-512.png",
         "sizes": "512x512",
         "type": "image/png",
         "purpose": "any maskable"
       }
     ]
   }

2. Create PWA icons:

   Create placeholder icons (can be replaced with proper branding):
   - public/icons/icon-192.png (192x192)
   - public/icons/icon-512.png (512x512)

   For now, create simple placeholder icons with "R" letter or rack symbol.

3. Update index.html:

   Add manifest link:
   <link rel="manifest" href="/manifest.json">

   Add theme color:
   <meta name="theme-color" content="#1a1a1a">

   Add Apple-specific meta tags:
   <meta name="apple-mobile-web-app-capable" content="yes">
   <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
   <meta name="apple-mobile-web-app-title" content="Rackarr">
   <link rel="apple-touch-icon" href="/icons/icon-192.png">

4. Create src/lib/utils/pwa.ts:

   isPWAInstalled(): boolean
   - Check display-mode: standalone

   canInstallPWA(): boolean
   - Check for beforeinstallprompt support

   PWA install prompt handling:
   - Store deferred prompt
   - Show custom install UI
   - Trigger native prompt on user action

5. Write tests in src/tests/pwa.test.ts:
   - Test: "manifest.json is valid JSON"
   - Test: "manifest has required fields"
   - Test: "isPWAInstalled returns true in standalone mode"
   - Test: "canInstallPWA checks for browser support"

Commit: "feat(pwa): add web app manifest and icons"
```

---

### Prompt 6.2 ‚Äî Service Worker

**Status:** ‚¨ú Pending
**Dependencies:** 6.1

```text
Create service worker for offline support.

1. Create public/sw.js:

   const CACHE_NAME = 'rackarr-v0.3.0';

   const APP_SHELL = [
     '/',
     '/index.html',
     '/manifest.json',
     '/icons/icon-192.png',
     '/icons/icon-512.png'
   ];

   // Install: cache app shell
   self.addEventListener('install', (event) => {
     event.waitUntil(
       caches.open(CACHE_NAME)
         .then(cache => cache.addAll(APP_SHELL))
         .then(() => self.skipWaiting())
     );
   });

   // Activate: clean old caches
   self.addEventListener('activate', (event) => {
     event.waitUntil(
       caches.keys()
         .then(keys => Promise.all(
           keys
             .filter(key => key !== CACHE_NAME)
             .map(key => caches.delete(key))
         ))
         .then(() => self.clients.claim())
     );
   });

   // Fetch: cache-first for app shell, network-first for assets
   self.addEventListener('fetch', (event) => {
     event.respondWith(
       caches.match(event.request)
         .then(cached => cached || fetch(event.request))
         .catch(() => caches.match('/index.html'))
     );
   });

2. Update src/main.ts to register service worker:

   if ('serviceWorker' in navigator) {
     window.addEventListener('load', () => {
       navigator.serviceWorker.register('/sw.js')
         .then(reg => console.log('SW registered:', reg.scope))
         .catch(err => console.error('SW registration failed:', err));
     });
   }

3. Update vite.config.ts:

   Add service worker to build output:
   - Copy sw.js to dist on build
   - Generate asset manifest for cache list

4. Create src/lib/stores/offline.svelte.ts:

   State:
   - isOnline: boolean ($state, from navigator.onLine)
   - serviceWorkerReady: boolean

   Effects:
   - Listen to 'online' and 'offline' events
   - Update isOnline state

5. Add offline indicator to toolbar:

   When offline:
   - Show cloud-off icon in toolbar
   - Subtle grey background tint
   - All functionality still works (local files)

6. Write tests in src/tests/serviceWorker.test.ts:
   - Test: "Service worker registers successfully"
   - Test: "App shell files are cached on install"
   - Test: "Cached responses returned when offline"
   - Test: "Old caches deleted on activate"
   - Test: "isOnline updates on network change"

Commit: "feat(pwa): add service worker for offline support"
```

---

### Prompt 6.3 ‚Äî Install Prompt

**Status:** ‚¨ú Pending
**Dependencies:** 6.2

```text
Create install prompt UI for PWA installation.

1. Create src/lib/components/InstallPrompt.svelte:

   Banner shown at bottom of screen:
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ üì± Add Rackarr to Home Screen  [X] ‚îÇ
   ‚îÇ [Install]              [Not Now]   ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

   Props: none (internal state)

   Visibility conditions:
   - Not already installed (standalone mode)
   - Browser supports installation
   - User has visited 2+ times
   - User has interacted (created rack or device)
   - Not dismissed in last 7 days

   Buttons:
   - Install: Trigger native install prompt
   - Not Now: Dismiss, save timestamp to localStorage

2. Create src/lib/stores/installPrompt.svelte.ts:

   State:
   - deferredPrompt: BeforeInstallPromptEvent | null
   - canShowPrompt: boolean
   - wasPromptShown: boolean
   - lastDismissed: Date | null

   Effects:
   - Listen for 'beforeinstallprompt' event
   - Store deferred prompt
   - Check localStorage for dismissal timestamp

   Actions:
   - showInstallPrompt(): void
   - dismissPrompt(): void
   - triggerInstall(): Promise<void>

3. Update src/lib/utils/pwa.ts:

   Add install tracking:
   - getVisitCount(): number
   - incrementVisitCount(): void
   - hasUserInteracted(): boolean
   - setUserInteracted(): void
   - getLastDismissed(): Date | null
   - setLastDismissed(): void

4. Add InstallPrompt to App.svelte:

   {#if $canShowPrompt && !$isPWAInstalled}
     <InstallPrompt />
   {/if}

5. Track user interaction:

   In layout store, after first rack created:
   setUserInteracted();

6. Write tests in src/tests/installPrompt.test.ts:
   - Test: "Install prompt hidden when already installed"
   - Test: "Install prompt hidden on first visit"
   - Test: "Install prompt shown after 2+ visits with interaction"
   - Test: "Dismiss hides prompt for 7 days"
   - Test: "Install button triggers native prompt"
   - Test: "Prompt hidden after successful install"

Commit: "feat(pwa): add install prompt UI"
```

---

## Phase 7: Mobile Polish

### Prompt 7.1 ‚Äî Touch Target Audit

**Status:** ‚¨ú Pending
**Dependencies:** 6.3

```text
Audit and fix touch target sizes across all mobile UI.

1. Create src/lib/utils/accessibility.ts:

   TOUCH_TARGET_MIN = 48; // px

   checkTouchTarget(element: HTMLElement): { valid: boolean; size: { width: number; height: number } }
   - Measure element's touch target size
   - Return whether it meets minimum

2. Audit and update components:

   Components to check/update:
   - ToolbarButton: Ensure 48x48px minimum
   - ActionSheet buttons: Ensure 48px height
   - BottomSheet handle: 48px tap area
   - RackNavigator buttons: 48x48px
   - DeviceLibraryItem: 48px height minimum
   - PositionSpinner buttons: 48x48px
   - USlotTarget: Extended tap area

   For each component:
   - Add .touch-target class where needed
   - Ensure padding/sizing meets minimum
   - Test with touch on mobile device

3. Update CSS for touch targets:

   .toolbar-button {
     min-width: var(--touch-target-min);
     min-height: var(--touch-target-min);
     padding: 12px;
   }

   /* Invisible tap area extension */
   .tap-extend::before {
     content: '';
     position: absolute;
     top: -8px;
     right: -8px;
     bottom: -8px;
     left: -8px;
   }

4. Fix U slot tap targets:

   U slots are 22px (below 48px minimum).
   Solution: Extend invisible tap area:

   .u-slot-target {
     position: relative;
   }
   .u-slot-target::before {
     content: '';
     position: absolute;
     top: -13px;
     bottom: -13px;
     left: 0;
     right: 0;
   }

5. Add visual feedback for all tappable elements:

   :active state with slight scale or color change
   for immediate touch feedback (< 100ms perceived)

6. Write tests in src/tests/touchTargets.test.ts:
   - Test: "All toolbar buttons meet 48px minimum"
   - Test: "All action sheet items meet 48px minimum"
   - Test: "U slot targets have extended tap area"
   - Test: "Device library items meet 48px minimum"
   - Test: "Navigation buttons meet 48px minimum"

Commit: "fix(a11y): ensure all touch targets meet 48px minimum"
```

---

### Prompt 7.2 ‚Äî Responsive Forms

**Status:** ‚¨ú Pending
**Dependencies:** 7.1

```text
Adapt form dialogs for mobile viewports.

1. Update src/lib/components/Dialog.svelte:

   Add mobile mode:
   - Desktop: Centered modal (existing)
   - Mobile: Full-screen or bottom sheet style

   Props:
   - fullScreenOnMobile?: boolean (default: true)

   Mobile styling:
   @media (max-width: 767px) {
     .dialog.full-screen-mobile {
       width: 100%;
       height: 100%;
       max-width: none;
       max-height: none;
       border-radius: 0;
       margin: 0;
     }
   }

2. Update NewRackForm.svelte:

   Mobile optimizations:
   - Larger input fields (48px height)
   - Radio buttons as large tappable cards
   - Full-width buttons
   - Numeric keyboard for height input (inputmode="numeric")

3. Update AddDeviceForm.svelte:

   Mobile optimizations:
   - Full-screen on mobile
   - Category as scrollable card grid
   - Color picker as swatches grid
   - Large touch-friendly inputs

4. Create src/lib/components/MobileInput.svelte:

   Touch-optimized input wrapper:
   - 48px minimum height
   - Clear button for text inputs
   - Proper inputmode attributes
   - Label positioning for mobile

   Props:
   - type: 'text' | 'number'
   - label: string
   - value: string | number
   - inputmode?: 'text' | 'numeric' | 'decimal'
   - clearable?: boolean

5. Create src/lib/components/RadioCardGroup.svelte:

   Touch-friendly radio alternative:
   - Large tappable cards
   - Visual selection state
   - Grid layout on mobile

   Props:
   - options: Array<{ value: string; label: string; description?: string }>
   - selected: string

6. Write tests in src/tests/mobileForms.test.ts:
   - Test: "Dialog renders full-screen on mobile"
   - Test: "Inputs have 48px minimum height on mobile"
   - Test: "Radio cards are tappable"
   - Test: "Numeric inputs show numeric keyboard"
   - Test: "Forms scroll properly when keyboard open"

Commit: "feat(forms): optimize forms for mobile viewports"
```

---

### Prompt 7.3 ‚Äî Mobile Toasts and Feedback

**Status:** ‚¨ú Pending
**Dependencies:** 7.2

```text
Optimize toast notifications for mobile.

1. Update src/lib/components/ToastContainer.svelte:

   Mobile positioning:
   - Desktop: Bottom-right corner
   - Mobile: Bottom-center, above bottom sheet

   @media (max-width: 767px) {
     .toast-container {
       bottom: calc(var(--mobile-bottom-sheet-handle) + 16px);
       left: 16px;
       right: 16px;
       align-items: center;
     }
   }

2. Update src/lib/components/Toast.svelte:

   Mobile optimizations:
   - Full width on mobile
   - Larger touch target for dismiss
   - Swipe to dismiss gesture

   Add swipe dismiss:
   use:gestures={{
     onPanLeft: handleSwipeDismiss,
     onPanRight: handleSwipeDismiss
   }}

3. Create contextual toasts for placement:

   Placement toast during two-tap flow:
   - Persistent (no auto-dismiss) while in placement mode
   - Shows device name and action hint
   - Cancel button to exit placement mode

   "Placing 2U Server ‚Ä¢ Tap a U position or [Cancel]"

4. Add toast queue management:

   On mobile, limit visible toasts:
   - Max 2 visible at once
   - Queue additional toasts
   - Auto-dismiss faster (3s vs 5s)

5. Update toast store:

   Add mobile-specific behavior:
   - Shorter default duration on mobile
   - Placement toast special handling
   - Queue management

6. Write tests in src/tests/mobileToasts.test.ts:
   - Test: "Toasts position above bottom sheet on mobile"
   - Test: "Toasts full width on mobile"
   - Test: "Swipe dismisses toast"
   - Test: "Max 2 toasts visible on mobile"
   - Test: "Placement toast persists during placement mode"
   - Test: "Placement toast cancel button works"

Commit: "feat(feedback): optimize toasts for mobile"
```

---

## Phase 8: Testing & Integration

### Prompt 8.1 ‚Äî Mobile E2E Tests

**Status:** ‚¨ú Pending
**Dependencies:** 7.3

```text
Write comprehensive E2E tests for mobile functionality.

1. Update playwright.config.ts:

   Add mobile device projects:

   projects: [
     // Existing desktop browsers...
     {
       name: 'Mobile Safari',
       use: { ...devices['iPhone 14'] }
     },
     {
       name: 'Mobile Chrome',
       use: { ...devices['Pixel 7'] }
     },
     {
       name: 'Mobile Safari SE',
       use: { ...devices['iPhone SE'] }
     }
   ]

2. Create tests/e2e/mobile-basic.spec.ts:

   Describe: "Mobile basic workflow"
   - Test: Create rack on mobile
   - Test: Verify rack appears in single rack view
   - Test: Navigate between racks with swipe
   - Test: Navigate between racks with buttons
   - Test: Open menu and access all actions
   - Test: Toggle theme from menu

3. Create tests/e2e/mobile-placement.spec.ts:

   Describe: "Mobile two-tap placement"
   - Test: Open device library sheet
   - Test: Search for device
   - Test: Tap device to select for placement
   - Test: Verify toast shows placement hint
   - Test: Tap U slot to place device
   - Test: Verify device appears in rack
   - Test: Cancel placement flow
   - Test: Error feedback on invalid placement

4. Create tests/e2e/mobile-gestures.spec.ts:

   Describe: "Mobile gestures"
   - Test: Pinch to zoom in
   - Test: Pinch to zoom out
   - Test: Double-tap to reset zoom
   - Test: Swipe left navigates to next rack
   - Test: Swipe right navigates to previous rack
   - Test: Long-press initiates drag mode

5. Create tests/e2e/mobile-pwa.spec.ts:

   Describe: "PWA functionality"
   - Test: Manifest is valid
   - Test: Service worker registers
   - Test: App works offline
   - Test: Install prompt appears after criteria met

6. Create tests/e2e/mobile-persistence.spec.ts:

   Describe: "Mobile persistence"
   - Test: Save layout downloads file
   - Test: Load layout from file
   - Test: Session storage preserves work

Commit: "test(e2e): add comprehensive mobile E2E tests"
```

---

### Prompt 8.2 ‚Äî Device Testing Matrix

**Status:** ‚¨ú Pending
**Dependencies:** 8.1

```text
Verify functionality across target device matrix.

1. Create tests/device-matrix.md:

   Document manual testing checklist:

   ## Primary Devices (Must Pass)
   - [ ] iPhone SE (375√ó667)
   - [ ] iPhone 14 (390√ó844)
   - [ ] Pixel 7 (412√ó915)
   - [ ] Samsung Galaxy S21 (360√ó800)

   ## Secondary Devices (Should Pass)
   - [ ] iPhone 14 Pro Max (430√ó932)
   - [ ] iPad Mini (768√ó1024)

   ## Test Scenarios Per Device
   - [ ] App loads correctly
   - [ ] Toolbar responsive at device width
   - [ ] Device library sheet opens/closes
   - [ ] Two-tap placement works
   - [ ] Pinch zoom responsive
   - [ ] Swipe navigation smooth
   - [ ] Forms usable with on-screen keyboard
   - [ ] PWA installable
   - [ ] Offline mode works

2. Add BrowserStack/Sauce Labs config (optional):

   If CI testing on real devices desired:
   - Add browserstack.config.ts
   - Add capability configs for target devices
   - Update CI workflow

3. Create visual regression baseline:

   Capture screenshots for:
   - Mobile toolbar
   - Device library sheet (collapsed, half, expanded)
   - Single rack view
   - Placement mode with toast
   - Edit sheet
   - Forms

4. Document known issues:

   Create KNOWN_ISSUES.md for mobile-specific quirks:
   - iOS Safari quirks
   - Android Chrome quirks
   - Gesture conflicts
   - Safe area edge cases

5. Update README with mobile testing instructions:

   ## Testing on Mobile
   - How to run mobile tests
   - How to test on real devices
   - Known device-specific issues

Commit: "test(devices): add device testing matrix and documentation"
```

---

### Prompt 8.3 ‚Äî Final Integration and Polish

**Status:** ‚¨ú Pending
**Dependencies:** 8.2

```text
Final integration pass and polish for v0.3 release.

1. Performance audit:

   Run Lighthouse mobile audit:
   - Target: Performance > 90
   - Target: Accessibility > 95
   - Target: Best Practices > 90
   - Target: PWA checkmarks all green

   Fix any issues found:
   - Optimize images/icons
   - Reduce JavaScript bundle
   - Fix accessibility issues
   - Complete PWA requirements

2. Cross-check all success criteria from v0.3-spec.md:

   - [ ] User can create racks on mobile phone
   - [ ] User can place devices using two-tap flow
   - [ ] User can move devices within and between racks
   - [ ] User can edit device and rack properties via sheet
   - [ ] User can navigate between racks via swipe or buttons
   - [ ] User can zoom canvas via pinch gesture
   - [ ] User can save/load layouts on mobile
   - [ ] User can export images on mobile
   - [ ] PWA is installable to home screen
   - [ ] App works fully offline
   - [ ] All touch targets meet 48px minimum
   - [ ] All mobile gestures have immediate visual feedback
   - [ ] Desktop experience unchanged
   - [ ] Hammer.js integrated for gesture handling
   - [ ] Pinch-to-zoom integrates with panzoom smoothly
   - [ ] No gesture conflicts between Hammer.js and panzoom

3. Verify desktop unchanged:

   Run full E2E suite on desktop:
   - All existing tests pass
   - No visual regressions
   - Drag-and-drop still works
   - Keyboard shortcuts still work

4. Code cleanup:

   - Remove console.log statements
   - Remove TODO comments (or document)
   - No TypeScript errors
   - No linting warnings
   - Update version to 0.3.0

5. Update documentation:

   - Update README with mobile features
   - Update CHANGELOG with v0.3.0 entry
   - Update help panel content

6. Final commit:

Commit: "chore: v0.3.0 release preparation"
```

---

## Progress Tracker

| Phase                    | Prompts            | Status |
| ------------------------ | ------------------ | ------ |
| 0. Foundation            | 0.1, 0.2           | ‚¨ú     |
| 1. Responsive Toolbar    | 1.1, 1.2           | ‚¨ú     |
| 2. Bottom Sheet System   | 2.1, 2.2, 2.3      | ‚¨ú     |
| 3. Mobile Canvas         | 3.1, 3.2           | ‚¨ú     |
| 4. Touch Gestures        | 4.1, 4.2, 4.3      | ‚¨ú     |
| 5. Two-Tap Placement     | 5.1, 5.2, 5.3, 5.4 | ‚¨ú     |
| 6. PWA Infrastructure    | 6.1, 6.2, 6.3      | ‚¨ú     |
| 7. Mobile Polish         | 7.1, 7.2, 7.3      | ‚¨ú     |
| 8. Testing & Integration | 8.1, 8.2, 8.3      | ‚¨ú     |

**Total Prompts:** 24
**Estimated Time:** 8-12 hours with Claude Code

---

## Dependency Graph

```
0.1 Platform Detection
 ‚îî‚îÄ‚îÄ 0.2 CSS Breakpoints
      ‚îú‚îÄ‚îÄ 1.1 Mobile Toolbar
      ‚îÇ    ‚îî‚îÄ‚îÄ 1.2 Action Sheet
      ‚îÇ         ‚îî‚îÄ‚îÄ 2.1 Bottom Sheet Base
      ‚îÇ              ‚îú‚îÄ‚îÄ 2.2 Device Library Sheet
      ‚îÇ              ‚îÇ    ‚îî‚îÄ‚îÄ 2.3 Edit Sheet
      ‚îÇ              ‚îÇ         ‚îî‚îÄ‚îÄ 3.1 Rack Navigator
      ‚îÇ              ‚îÇ              ‚îî‚îÄ‚îÄ 3.2 Single Rack View
      ‚îÇ              ‚îÇ                   ‚îî‚îÄ‚îÄ 4.1 Hammer.js
      ‚îÇ              ‚îÇ                        ‚îú‚îÄ‚îÄ 4.2 Pinch Zoom
      ‚îÇ              ‚îÇ                        ‚îÇ    ‚îî‚îÄ‚îÄ 4.3 Swipe Nav
      ‚îÇ              ‚îÇ                        ‚îÇ         ‚îî‚îÄ‚îÄ 5.1 Selection State
      ‚îÇ              ‚îÇ                        ‚îÇ              ‚îî‚îÄ‚îÄ 5.2 U Slot Targets
      ‚îÇ              ‚îÇ                        ‚îÇ                   ‚îî‚îÄ‚îÄ 5.3 Placement Feedback
      ‚îÇ              ‚îÇ                        ‚îÇ                        ‚îî‚îÄ‚îÄ 5.4 Long-Press Drag
      ‚îÇ              ‚îÇ                        ‚îÇ                             ‚îî‚îÄ‚îÄ 6.1 Manifest
      ‚îÇ              ‚îÇ                        ‚îÇ                                  ‚îî‚îÄ‚îÄ 6.2 Service Worker
      ‚îÇ              ‚îÇ                        ‚îÇ                                       ‚îî‚îÄ‚îÄ 6.3 Install Prompt
      ‚îÇ              ‚îÇ                        ‚îÇ                                            ‚îî‚îÄ‚îÄ 7.1 Touch Targets
      ‚îÇ              ‚îÇ                        ‚îÇ                                                 ‚îî‚îÄ‚îÄ 7.2 Mobile Forms
      ‚îÇ              ‚îÇ                        ‚îÇ                                                      ‚îî‚îÄ‚îÄ 7.3 Mobile Toasts
      ‚îÇ              ‚îÇ                        ‚îÇ                                                           ‚îî‚îÄ‚îÄ 8.1 E2E Tests
      ‚îÇ              ‚îÇ                        ‚îÇ                                                                ‚îî‚îÄ‚îÄ 8.2 Device Matrix
      ‚îÇ              ‚îÇ                        ‚îÇ                                                                     ‚îî‚îÄ‚îÄ 8.3 Final Polish
```

---

## Execution Notes

### Before Starting

1. Ensure v0.2 is complete and stable
2. Verify all v0.2 tests pass
3. Have v0.3-spec.md open for reference
4. Install required test devices or emulators

### During Execution

1. Write tests FIRST (TDD)
2. Run tests after each change
3. Test on mobile emulator frequently
4. Commit after each successful prompt
5. Mark prompts complete in this file

### Key Technical Decisions

1. **Hammer.js for gestures** ‚Äî Battle-tested, cross-browser
2. **Bottom sheets replace drawers** ‚Äî Mobile-native pattern
3. **Two-tap placement** ‚Äî More accessible than drag on touch
4. **Progressive enhancement** ‚Äî Desktop unchanged, mobile layered on
5. **Service worker cache-first** ‚Äî App shell cached, works offline

### If Stuck

1. Re-read the prompt and spec
2. Check mobile emulator for visual issues
3. Test on real device if emulator unclear
4. Check Hammer.js docs for gesture conflicts
5. Verify panzoom + Hammer integration

### Quality Gates (Pre-commit)

- ESLint must pass
- Prettier formatting applied
- All tests must pass (desktop AND mobile)
- No TypeScript errors
- Lighthouse mobile score > 90

---

_Generated following Harper Reed LLM Codegen Methodology_
_Builds on v0.2 codebase with mobile-first additions_
